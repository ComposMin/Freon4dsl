{
  
  "1": {
    "title": "PiAction",
    "content": "PiAction . An object that implements PiAction &lt;TODO&gt; . export interface PiActions { expressionCreators: PiExpressionCreator[]; binaryExpressionCreators: PiBinaryExpressionCreator[]; customBehaviors: PiCustomBehavior[]; keyboardActions: KeyboardShortcutBehavior[]; } .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/interfaces/action-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/interfaces/action-interface.html"
  }
  ,"2": {
    "title": "Customizability",
    "content": "Overview of the Generated Pi-tools and Their Customizability . ProjectIt generates an integrated set of tools that support the language that you are creating. As described in Three :Levels to Customize ProjectIt these tools can be customized. . This page gives an overview of these tools, and shows how you can adjust them to your needs. See The Five Definition Files for an explanation of the level 2 definitions. . Workbench Part has Default level 2 definition level 3 definition . language structure . | no . | .ast . | no . | . projectional editor . | yes . | .edit . | yes . | . scope provider . | yes . | .scope . | not yet . | . validator . | yes . | .valid . | yes . | . type provider . | yes . | .type . | not yet . | . standard library . | yes . | .ast . | not yet . | . parser . | yes . | .edit . | yes (using pegjs) . | . unparser . | yes . | .edit . | not yet . | . json exporter/importer . | yes . | .ast . | no . | . visitor pattern implementation . | yes . | .ast . | can be extended . | . web application . | yes . | none . | can be changed or replaced . | . If you are using ProjectIt, and are missing a specific tool or feature, please let us know through info AT projectit.org. .",
    "url": "http://localhost:4000/version-0.1.0/pages/starting/adaptability.html",
    "relUrl": "/version-0.1.0/pages/starting/adaptability.html"
  }
  ,"3": {
    "title": "PiBinaryExpression",
    "content": "PiBinaryExpression . An object that implements PiBinaryExpression can be a node in the model AST. It represents an expression that has exactly two operands, which are usually written to the left and right of the operator symbol. For example, &#39;4+5&#39;. . This interface extends the PiExpression interface. . export interface PiBinaryExpression extends PiExpression { piLeft(): PiExpression; piSetLeft(left: PiExpression): void; piRight(): PiExpression; piSetRight(right: PiExpression): void; piPriority(): number; } .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/interfaces/binary-expression-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/interfaces/binary-expression-interface.html"
  }
  ,"4": {
    "title": "Source Code Documentation",
    "content": "Source Code Documentation . The source code for the development of ProjectIt is organised into the following packages. . docs: documentation, i.e. this website . | packages/core: framework source code. . packages/core/src/editor: the editor framework source code. . | packages/core/src/language/decorators: source code for MobX decorators that can be used to easily implement a language that can be directly used by ProjectIt. . | . | packages/meta: source code that reads the language definition files and generates the language environment. . packages/meta/src/languagedef: source code that generates code from a language structure definition (.ast) file. . | packages/meta/src/editordef: source code that generates code from an editor definition (.edit) file. . | packages/meta/src/scoperdef: source code that generates code from a scoper definition (.scope) file. . | packages/meta/src/typerdef: source code that generates code from a typer definition (.type) file. . | packages/meta/src/validatordef: source code that generates code from a validator definition (.valid) file. . | . | packages/playground: source code generated from the language definition files. . packages/playground/src/webapp: a copy of packages/webapp, for use within the playground. . | packages/playground/src/demo/defs: the language definition files for the example language called &#39;demo&#39;. . | . | packages/server: source code for a minimalistic model-server used for demonstration purposes. . | packages/webapp: source code for the web-application used for all generated languages. . | /*: the usual suspects. . | . In future this page will refer to the generated javadoc pages. .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/code-documentation.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/code-documentation.html"
  }
  ,"5": {
    "title": "Project Structure",
    "content": "Project Structure . This description of the project structure of a ProjectIt project is based om the https://github.com/projectit-org/ProjectIt-example project which you can clone from github. . The source code (~/src) in a ProjectIt project is organised into the following subfolders. . Note that the defs and picode folders can have any name as long as both the generate script in package.json, and the configuration of the web application in the file ~/src/webapp/WebappConfiguration.ts, are adjusted. (See Start with the Template project.) . defs: the language definition files. . | picode: the generated source code. . picode/editor: code for the editor. This folder contains two files that will not be overwritten at regeneration: Custom&lt;yourLanguageName&gt;Actions.ts and Custom&lt;yourLanguageName&gt;Projection.ts. These are the placeholders for any third-level customization that you would like to do. . | picode/environment: code that provides the coupling between all parts of the generated workbench. . | picode/language: code that implements the language structure. . | picode/projectit: code that enables the language engineer to configure the workbench. This folder contains one file that will not be overwritten at regeneration: ProjectitConfiguration.ts. Here you can configure any third-level customization that you want the generated code to take into account. . | picode/reader: a parser that is able to read model units from a text string or file. . | picode/scoper: code for that determines which elements are visible for a certain element in the user&#8217;s model. . | picode/stdlib: code that implements some standard elements of your language, for instance limited concepts. . | picode/typer: code that that determines which type is associated with a certain element in the user&#8217;s model. . | picode/utils: a default implementation of a visitor for your user&#8217;s model. . | picode/validator: code that determines whether or not certain parts of your user&#8217;s model contain errors. . | picode/writer: code that is able to write your user&#8217;s model units in string format to a file. . | . | webapp: source code for the web-application used for all generated languages. . Note worthy is the file picode/webapp/WebappConfiguration.ts. This file holds the references to the generated language workbench and the web address of the server which stores your user&#8217;s models. . | . | . | Be careful with handmade changes in picode, all files in any folder called gen will be deleted during the next generation. | . Another folder that can be found in the project is ~/modelstore. This is the folder where the server stores all models, and it is created at the moment that the server is started. Each model is stored in a separate folder in which you can find its modelunits as .json files. . The gen subfolders . The contents of all folders in ` picode` is divided into classes that are contained directly in the folder, and classes that are contained in the subfolder gen. The latter are always removed before regeneration, so be careful not to add important code to the gen folder. Code that is contained directly in each folder is not changed upon regeneration. . The webapp and server . For the language environment to function, more is needed than the code for the editor, validator and such. In particular, there is a need for a server which can hold and provide stored users models, and for a small web application that is able to show the editor, errors message, models that are available form the server, and so on. . Therefore, we provide a minimal server that stores your user models in a json format. You can start it through the commandline: . yarn model-server . A simple web application where you can see your language in action is also provided. The code can be found in ~/webapp. . Note that both the server and the web application are provided for your convenience. We assume that when ProjectIt is used in a larger context, these two parts will be interchanged with suitable choices made by the language engineer and team. .",
    "url": "http://localhost:4000/version-0.1.0/pages/starting/code-organisation.html",
    "relUrl": "/version-0.1.0/pages/starting/code-organisation.html"
  }
  ,"6": {
    "title": "Calling The Generator",
    "content": "Use of the ProjectIt Generator . The ProjectIt commandline tool generates code from the various definition files as described in Language Definitions If you type ‘projectit’ in a (bash) terminal you will see an overview of the different arguments that can be used. For detailed help about a specific command, type: ‘projectit &lt;command&gt; -h’. . Figure 1. Screenshot of commandline options Note that every command except all, used invididually (i.e. without the other commands), generates code that does not compile correctly. . For instance, both the scoper and validator might need to use the typer, therefore the code seeks to include the typer class, which might not be generated yet. Likewise, the editor seeks to include the scoper. . Best way to go about is to first use the all command. Next, when you focus on one of the aspects of your language, you can use the specific command for that aspect. Thus, you can keep regeneration-time as short as possible. . Note that there also is a -watch option to automatically run the generator when a definition file changes. .",
    "url": "http://localhost:4000/version-0.1.0/pages/starting/commandline.html",
    "relUrl": "/version-0.1.0/pages/starting/commandline.html"
  }
  ,"7": {
    "title": "The ProjectIt Core Interfaces",
    "content": "The ProjectIt Core Interfaces . There are two series of interfaces that make ProjectIt and its generated code extensible and flexible. The first series are the interfaces of the generated code. . The second series of interfaces are those that define parts of the core of the ProjectIt framework: . PiProjection . | PiActions . | PiExpression . | PiBinaryExpression . | In both series the following two interfaces are used: . PiElement . | PiNamedElement . |",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/interfaces/core-interfaces-intro.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/interfaces/core-interfaces-intro.html"
  }
  ,"8": {
    "title": "Writing Actions in TypeScript",
    "content": "Writing Actions in TypeScript . In the ProjectIt editor all behavior is defined using actions. Although ProjectIt is implemented using React, actions abstract away from this implementation. . Each action defines . The trigger . | The action itself . | The boxes in which the action can be triggered . | An id for internal use . | . Let&#8217;s take a look at the definition of a behavior: . export interface PiBehavior { /** * The trigger to activate this behavior */ trigger: PiTriggerType; /** * The box roles in which this trigger is active */ activeInBoxRoles: string[]; /** * Optional callback function that returns whether the trigger is applicable for the specific box. */ isApplicable?: (box: Box) =&gt; boolean; boxRoleToSelect?: string; caretPosition?: PiCaret; } . User actions are attached to boxes. This is done by adding these box roles to the activeInBoxRoles property of an action. . The trigger defines the keys that will trigger execution of the action. . Custom Actions . To Be Done . Expressions and Binary Expressions . Advanced expression editing is described in Expressions. . Keyboard Shortcuts . A keyboard shortcut specifies an action that is triggered by special keys, like e.g. Ctrl-A. .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/framework/defining_actions.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/framework/defining_actions.html"
  }
  ,"9": {
    "title": "Boxes",
    "content": "Boxes . A Box is an abstract class describing the features that are common for all boxes. As explained in the editor framework, each box has a mandatory model element and role. The following boxes are available. . Primitive Boxes Grouping Boxes . LabelBox . | HorizontalListBox . | . TextBox . | VerticalListBox . | . TextBox . | GridBox . | . SpacerBox . | VerticalPiElementListBox . | . AliasBox . | | . LabelBox . A LabelBox shows a non-editable text. The text itself can either be a fixed string (1), or it can be defined as a function (2). Being a function allows the label text to change dynamically, depending on the result value of the function. . new LabelBox(element, &quot;role&quot;, &quot;fixed text&quot;) (1) new LabelBox(element, &quot;role&quot;, () =&gt; element.value) (2) . TextBox . A TextBox shows an editable text. In addition to the element and the role a text box needs two function parameters. The first function to get the value of the text, the second function to set the value of the text. . new TextBox( element, &quot;role&quot;, () =&gt; element.stringValue, (newValue: string) =&gt; element.stringValue = newValue ) . There are two options you can set for a TextBox: . These options control what happens when a textbox becomes empty, i.e. contains no characters. . SvgBox . An SvgBox shows a single SVG image. . ListBox . A ListBox is a list of child boxes, either horizontally or vertically. The ListBox itself is abstract. . HorizontalListBox . A HorizontalListBox show a list of child boxes next to each other horizontally. . An example of using a HorizontalListBox is the following that represents the projection of a StringLiteral. . Unresolved directive in different-boxes.adoc - include::../../../../../core/src/test/testeditor/CoreTestProjection.ts[tag=StringLiteral] . VerticalListBox . A VerticalListBox show a list of child boxes next to each other vertically. . It&#8217;s usage is similar to that of the HorizontalListBox. . VerticalModelElementListBox . A VerticalModelElementListBox show a list of PiElement objects, where each ModelElement will be shown according to its defined projection. . This box is a special case of a VerticalListBox, to show a list of child elements. A special property of this type of box is the elementCreator(). This is a function thet should create a new element that fits in the collection. Given this, the VerticalModelElementListBox generates the editor for the element list, including the neccesary behavior to add and remove elements from the list. . GridBox . A GridBox is used to show boxes in a tabular fashion. . SelectBox . A SelectBox is used to show a selection to the user. . AliasBox . An AliasBox is a box where the user can type text (printable characters), which is used as an alias for some action. .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/framework/different-boxes.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/framework/different-boxes.html"
  }
  ,"10": {
    "title": "Editor Definition",
    "content": "The Editor Definition . Three-level definition . As explained in Three-levels to Customize your Pi-tools the generated editor can be defined at three levels. For each concept in the AST the editor will . use the hand-made projection, when this is present. Otherwise the editor will . | use to the projection generated from the editor definition, when this definition is present. Finally, the editor will . | use the default projection. . | When a concept is marked as an binary expression concept, its default projection is usually the one you want to go with, because of the extra support for expressions that is incorporated in it. . The rest of this tutorial explains the 2nd level: how to write an editor definition (.edit file). For making more adjustments to the projection by adding hand-made projections on the 3rd level, see the tutorial on using the framework. . The Editor Definition File . In the editor definition file (.edit file) you can define a ProjectIt editor by providing extra information for each concept in your language. Currently, you can define the following three items. . Projection, which is how the concept is shown in the editor. . | Trigger, which is the key or keys your user needs to type to create a new instance of the concept. . | Symbol, which is optional and only used for binary expressions. It is the character or character string that is shown when a binary expression is being added to your user’s model. When the symbol is not present, the trigger will be used. . | . Projections . In the .edit file a projection is defined between angular brackets. This is done in a style similar from markdown, what you see looks close to what you get. Everything within the square brackets ([]), except the parts surrounded by ${ }, is taken literally, including any indentation. . Text { @projection [This is literal text that is projected in the editor for every concept of type Text.] } . When the indentation of the opening and closing brackets aligns, this indentation is not taken into account. The column in which the brackets appear is seen as the first column of the projection. The above example will show the text &quot;This is&quot; at the beginning of the line [1], but the text &quot;for every concept of type Text&quot; will be shown with an indentation of 8 spaces. If the closing bracket would be positioned on the line after the text, and it would have been indented with 8 spaces, then the text &quot;for every concept of type Text&quot; would be shown without any indentation. . StringLiteralExpression { // in this projection the indentation is not taken into account @projection StringLiteralExpression [ &#39;${self.value}&#39; ] @trigger &quot;&#39;&quot; } AttributeWithLimitedType { // in this projection the indentation is taken into account @projection attribuut [ ${self.name} : ${self.declaredType} ] } . Using ‘[+’ you can indicate that a newline should be added. . FunctionCallExpression { @projection FunctionCallExpression [+ CALL ${self.functionDefinition} ( ) ] @trigger &quot;function&quot; } . Including Subprojections . Using ${ } you tell ProjectIt to include a property. Its projection is defined by the projection for its concept. . In the following example ${self.condition} is a property of type BooleanLiteralExpression. It will be projected according to the definition for this concept, whereas ${self.whenTrue} is a property of type EntityExpression, which is abstract. This property will be projected according to the definition for subtype of EntityExpression that is currently found. . IfExpression { @projection IfExpression [ if (${self.condition}) then ${self.whenTrue} else ${self.whenFalse} endif ] @trigger &quot;if&quot; @symbol &quot;if&quot; } . Lists . If a property is a list, you can indicate whether it should be projected horizontally or vertically. The default is horizontal. . Furthermore, you can add either a separator string in between all elements, or a terminator string after each element. Both are optional. . EntityModelUnit { @projection EntityModelUnit [ model ${self.name} { entities: ${self.entities @vertical @terminator [ n n] } model wide functions: ${self.functions @horizontal @separator [; ] } } ] } . . 1. This is not completely true. There will be no indentation in the block that is generated by this projection. However, the projection as a whole may be indented because it is included in another (bigger) projection.",
    "url": "http://localhost:4000/version-0.1.0/pages/second-level/editdef-tutorial.html",
    "relUrl": "/version-0.1.0/pages/second-level/editdef-tutorial.html"
  }
  ,"11": {
    "title": "The Editor Framework",
    "content": "The Projectional Editor Framework . The Projectional Editor Framework is written in TypeScript and based on React. This page provides an overview of the Framework. If you want to get deeper into this, see the tutorial How to Use the ProjectIt Framework. . Projection Layout Based on Boxes . The layout of every visible element in the editor is based on boxes. A box is a rectangular area in the editor. A box can contain any number of child boxes. Every AST node is projected in a box. . A small example to start with: . Figure 1. Mapping a StringLiteral The figure shows the projection of the concept StringLiteral. This is mapped to a horizontal list of a quote (&quot;), an editable text with the value of the StringLiteral, and a closing quote (&quot;). Note that the quotes are not part of the AST. They are part of the concrete syntax used in this projection of the AST. . In TypeScript this projection might look something like: . new HorizontalListBox( [ new LabelBox(&quot; &quot;&quot;), new TextBox(stringLiteral.value), new LabelBox(&quot; &quot;&quot;) ]); . There are a large number of different types of boxes. See Boxes for an overview. . Every projection must implement the PiProjection interface. . Coupling Behavior to Boxes . User actions on boxes need to be translated into interactions with the projected AST. To know which part of the projection represents the AST node, we give each Box in the projection a role, which is unique within its parent box. This way we can identify every box by its model element plus its role. . In the following figure the roles are shown above the boxes in green. . Figure 2. Mapping a StringLiteral with Roles We can now show the full typescript code for this projection. Given that literal is the StringLiteral object: . new HorizontalListBox(literal, &quot;string-literal&quot;, [ (1) new LabelBox(literal, &quot;start-quote&quot;, &#39;&quot;&#39;), (2) new TextBox( (3) literal, &quot;string-value&quot;, () =&gt; literal.value, (v: string) =&gt; (literal.value = v) ), new LabelBox(literal, &quot;end-quote&quot;, &#39;&quot;&#39;) (4) ]) . 1 | The overall horizontal list box to group everything | . 2 | The first label box for the start quote | . 3 | The text box for the value of the string literal | . 4 | The second label box for the end quote | . The behavior coupled to a Box is defined by an action. To identify which action should be executed, each behavior is specified by: . one or more box roles, specifying that the behavior is only active in boxes with that specific role, . | a trigger, describing the key(s) that will trigger the behavior, and . | an action, which is a typescript/javascript function the will be executed when the behavior is being triggered. . | . Actions are further described in Actions. .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/framework/editor-framework.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/framework/editor-framework.html"
  }
  ,"12": {
    "title": "Customization of the Editor",
    "content": "Third Level Customization of the Editor . The two interfaces that define the editor are the PiProjection and the PiAction. . Customizing Projections . When generating the code for a language, there is a default implementation of PiProjection that will be generated into the file editor/gen/&lt;LANGUAGE&gt;ProjectionDefault.ts. This file contains projections for all concepts in the language. If there is a projection defined in the .edit file this will be generated, if theree is no projection defined, a default prrojection will be generated. . In addition, the file editor/Custom&lt;LANGUAGE&gt;Projection.ts is generated, which is a placeholder for writing projections in TypeScript. . What you need to do is to implement the getBox(&#8230;&#8203;) method below. . Code Sample 1. getBox projection getBox(element: PiElement): Box { // Add any handmade projections of your own before next statement return null; } . If you want to add a projection for a concept, you need to return the Box for this concept. Simple return null for all other concepts. This way ProjectIt will know that you did not define aa projection yourself and will use the projection defined in &lt;LANGUAGE&gt;ProjectionDefault. . In the tutorial Writing projections in TypeScript you can learn how to actually write projections in code. . Customizing Actions . The projections only describe what you will see in the editor. Actions determine what you can do, how you interect with the editor. . ProjectIt ill generate default actions for navigation in a model and for creating and deleting elements in a model. This is done in the file editor/&lt;LANGUAGE&gt;DefaultActions.ts. . In addition, the file editor/Custom&lt;LANGUAGE&gt;Actions.ts is generated, which is a placeholder for writing projections in TypeScript. . This file contains four constants for different kind of actions: . Code Sample 2. getBox projection export const MANUAL_EXPRESSION_CREATORS: PiExpressionCreator[] = [ // Add your own custom expression creators here ]; export const MANUAL_BINARY_EXPRESSION_CREATORS: PiBinaryExpressionCreator[] = [ // Add your own custom binary expression creators here ]; export const MANUAL_CUSTOM_BEHAVIORS: PiCustomBehavior[] = [ // Add your own custom behavior here { trigger: &quot;attribute&quot;, (2) activeInBoxRoles: [&quot;end-of-attribute-list&quot;], (1) action: (box: Box, trigger: PiTriggerType, editor: PiEditor): PiElement | null =&gt; { (3) var entity: Entity = box.element as Entity; const attribute: AttributeWithLimitedType = new AttributeWithLimitedType(); entity.attributes.push(attribute); return attribute; }, boxRoleToSelect: &quot;Attribute-name&quot; (4) }, ]; export const MANUAL_KEYBOARD: KeyboardShortcutBehavior[] = [ // Add your own custom keyboard shortcuts here ]; . What you need to do is to define these contants. . ProjectIt will merge your actions with the default actions. If a trigger for an action is identical, your actions take precedence over the default actions. . In the tutorial Writing Actions in TypeScript you can learn how to write the actions in TypeScript. .",
    "url": "http://localhost:4000/version-0.1.0/pages/third-level/editor-third-level.html",
    "relUrl": "/version-0.1.0/pages/third-level/editor-third-level.html"
  }
  ,"13": {
    "title": "PiElement",
    "content": "PiElement . As ProjectIt uses the AST for projections and behavior, it needs to know about the type of elements in the AST. To allow ProjectIt to work, each element type that occurrs in the AST needs to implement the PiElement interface. This interface is kept as small as possible, to allow ProjectIt to be used for any AST. . export interface PiElement { piId(): string; piLanguageConcept(): string; piContainer(): PiContainerDescriptor; piIsModel(): boolean; piIsUnit(): boolean; piIsExpression(): boolean; piIsBinaryExpression(): boolean; } . The main two elements in this interface are: . piId(), which should return en unique id for each element in the AST. . | piContainer() which should return a descriptor for the container (parent) of an element in the AST. . | . The two functions piIsExpression() and piIsBinaryExpression() are only needed when your language contains expressions, as ProjectIt includes special handling of expressions. To start with, these functions can be defined to simply return false. . Note that ProjectIt does not need to know anything about the structure of your language. No need to know the availale element type, nor the properties of en element type, nor anything else. This is by design, as ProjectIt is not meant to be a full Language Workbench, but instead meant to be used with multiple language workbenches , or none. .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/interfaces/element-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/interfaces/element-interface.html"
  }
  ,"14": {
    "title": "PiEnvironment",
    "content": "PiEnvironment . An object that implements PiEnvironment holds the information about where to find all parts of the language environment. It is usually a singleton object. . export interface PiEnvironment { /** * Creates a new model, an implementation of the language defined in the .ast file * @param name */ newModel(name: string): PiModel; scoper: PiScoper; typer: PiTyper; validator: PiValidator; editor: IPiEditor; stdlib: PiStdlib; writer: PiWriter; reader: PiReader; // projectionalEditorComponent: ProjectionalEditor; languageName: string; unitNames: string[]; } .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/tools-interfaces/environment-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/tools-interfaces/environment-interface.html"
  }
  ,"15": {
    "title": "PiExpression",
    "content": "PiExpression . An object that implements PiExpression &lt;TODO&gt; . export interface PiExpression extends PiElement { } .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/interfaces/expression-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/interfaces/expression-interface.html"
  }
  ,"16": {
    "title": "Support For Expressions",
    "content": "Support For Expressions . Editing expressions in a projectional editor is a well-known challenge. The representation of an expression in the AST is highly structured. Yet, because its appearance to the user looks textual, users expect that the editing behavior resembles classical text editing as much as possible. . In Efficiency of Projectional Editing: A Controlled Experiment the authors express the problem as follows. . Improving Expression Editing. Editing expressions with their fine-grained tree structure is one of the major challenges in a projectional editor. The inability to insert and remove parentheses in arbitrary places (and then refactor the treestructure according to the precedence expressed by the parentheses) is an example. . &#8212; Markus Voelter a.o. Efficiency of Projectional Editing For this reason, ProjectIt has in-build support for expressions. There is extra functionality to be able to add an expression before or after an existing expression. Secondly, the AST of any binary expression is automatically balanced. . Adding to an existing expression . Figure 1. Editing expressions In the above figure, when the user types a + symbol after the *, it is not enough to simply add the + in the AST. . First of all, a placeholder should be added to make the xpression strcuturally correct, so we should see something like . a * &#8230;&#8203; + b. . | . | Doing so will lead to the second AST shown. . | But &#8230;&#8203; this AST is not balanced right! . When adding parenthesis to show the AST, this will look like a * (&#8230;&#8203; + b) . | But the user (using his knowledge of priorities of * and + will read (a * &#8230;&#8203;) + b. . | . | Therefore the AST needs to be re-balanced to take the priorities of the multiplication and addition into account. This re-balancing leads to the trhird AST show, where the structure of the AST properly reflects what the user understands. . | . ProjectIt understands this kind of tree balancing and will automatically apply them while editing expressions. .",
    "url": "http://localhost:4000/version-0.1.0/pages/intro/expressions.html",
    "relUrl": "/version-0.1.0/pages/intro/expressions.html"
  }
  ,"17": {
    "title": "Writing Projections in TypeScript",
    "content": "Writing Projections in TypeScript . As explained in Your Own Language - Overview the five aspects of the generated workbench can be defined in three levels. . This tutorial explains the third level, i.e. creating handwritten code, of the definition of the editor. . How to Use the ProjectIt Editor Framework . The ProjectIt Editor Framework can be used directly, by writing Typescript that uses the classes in @projectit/core. If you want to do this, there are two axes along which you can specify your editor: (1) hand-build projections and (2) hand-build actions. . Before you dive into this, we suggest that you become familiar with the information in the ProjectIt Framework. . Define your own Projection . As you known from the ProjectIt Framework, all projections are based on boxes. In the next few steps we will show you how to build a hierarchy of boxes to project your AST nodes, and how to style these boxes according to your wishes. . The projections in this tutorial are available in the ProjectIt-example. . Step 1 - Projecting a Simple Attribute . We start with building the projection for a simple attribute of type string: the name of the unit in our Entity language. In the metamodel this is represented by the value of the attribute name of class EntityModelUnit . Code Sample 1. EntityModelUnit Element private createModelBox(model: EntityModelUnit): Box { return new HorizontalListBox(model, &quot;model&quot;, [ new LabelBox(model, &quot;model-label&quot;, &quot;Model&quot;), new TextBox(model, &quot;model-name&quot;, () =&gt; model.name, (c: string) =&gt; (model.name = c)) ]); } . An obvious choice for the projection of this attribute is a HorizontalListBox which holds a LabelBox with the name of the class, followed by the value stored in the variable unit.name. In the tutorial example this value is &quot;EntityModel&quot;. When we start the editor based on this projection, we see the following: . It doesn&#8217;t look very nice currently: . The label is not distinguishable from the name of the model. . | When the name of the model becomes empty, there is no visual clue that you can add a name. . | . Step 1.1 - Adding Style and a PlaceHolder . To make the label look different from the value of the attribute, we need to take a look at the code that implements the default projection: . Code Sample 2. Simple Projection private createModelBox(model: EntityModelUnit): Box { return new HorizontalListBox(model, &quot;model&quot;, [ new LabelBox(model, &quot;model-label&quot;, &quot;Model&quot;), new TextBox(model, &quot;model-name&quot;, () =&gt; model.name, (c: string) =&gt; (model.name = c)) ]); } . Let&#8217;s first add a style to the LabelBox: . Code Sample 3. Projection with Style and Placeholder private createModelBox2(model: EntityModelUnit): Box { return new HorizontalListBox(model, &quot;model&quot;, [ new LabelBox(model, &quot;model-label&quot;, &quot;Model&quot;, { style: styleToCSS(projectitStyles.keyword) }), new TextBox(model, &quot;model-name&quot;, () =&gt; model.name, (c: string) =&gt; (model.name = c), { placeHolder: &quot;&lt;name&gt;&quot; }) ]); } . We associated the LabelBox with the style demoStyles.keyword, so it will show in a different color. . Also, we have given the TextBox has a placeHolder property. This placeholder will show whenever the contents of the TextBox is empty, giving the user a visual clue that a name could be entered. . The result is: . The style is defined in a css (or actually scss) as follows. In principle all CSS styles can be used here. . Code Sample 4. CSS for Styled Projection Unresolved directive in framework-tutorial.adoc - include::../../../src/tutorial-language/editor/styles/style.scss[tag=StyleKeyword] . Step 2 - Projecting a List . Next we will add the entities attribute owned by the EntityModelUnit to the projection. The entities attribute is a list of Entity. Now take a look at the projection. . Code Sample 5. Projection of Child Elements private createModelBox3(model: EntityModelUnit): Box { return new VerticalListBox(model, &quot;model&quot;, [ new HorizontalListBox(model, &quot;model-info&quot;, [ new LabelBox(model, &quot;model-keyword&quot;, &quot;Model&quot;, { style: styleToCSS(projectitStyles.keyword) }), new TextBox(model, &quot;model-name&quot;, () =&gt; model.name, (c: string) =&gt; (model.name = c), { placeHolder: &quot;&lt;name&gt;&quot; }) ]), new LabelBox(model, &quot;entity-keyword&quot;, &quot;Entities&quot;, { style: styleToCSS(projectitStyles.keyword) }), new VerticalListBox( model, &quot;entity-list&quot;, model.entities.map(ent =&gt; { return this.rootProjection.getBox(ent); }) ) ]); } . The entities attribute is to be shown as a vertical list, therefore we use a VerticalListBox. The first element of this list is a label, like the LabelBox in the previous step, styled as a keyword. The entities themselves are projected in another VerticalListBox. . The projection of a single Entity is defined in a separate function, thus building a hierarchy of boxes. Note that the projection of the Entity is done using this.rootPrtojection.getBox(ent),. This ensures that the proper projection for entity is used, see customize projections . Code Sample 6. Projection of Entity private createEntityBox(entity: Entity): Box { return new VerticalListBox(entity,&quot;entity&quot;, [ new HorizontalListBox(entity, &quot;entity-info&quot;, [ new LabelBox(entity, &quot;entity-keyword&quot;, &quot;Entity&quot;, { style: styleToCSS(projectitStyles.keyword) }), new TextBox(entity, &quot;entity-name&quot;, () =&gt; entity.name, (c: string) =&gt; (entity.name = c), { placeHolder: &quot;&lt;name&gt;&quot; }) ]), new VerticalListBox( entity, &quot;attribute-list&quot;, entity.attributes.map(att =&gt; { return this.rootProjection.getBox(att); }) ) ] ); } . The projection function is very similar to the projection of the EntityModel, showing the keyword Entity followed by its name and below all attributes of the entity in a VerticalListBox. . Once again, the projection of an attribute is defined in its own function. . Code Sample 7. EntityAttribute Element concept AttributeWithLimitedType { reference declaredType: AttributeType; } . Code Sample 8. Projection of EntityAttribute return new HorizontalListBox( attribute, &quot;Attribute&quot;, [ new TextBox( attribute,&quot;Attribute-name&quot;, () =&gt; attribute.name, (c: string) =&gt; (attribute.name = c as string), ), new LabelBox(attribute, &quot;attribute-label&quot;, &quot;: &quot;), this.getReferenceBox( attribute, &quot;Attribute-declaredType&quot;, &quot;&lt;select declaredType&gt;&quot;, &quot;AttributeType&quot;, () =&gt; { if (!!attribute.declaredType) { return { id: attribute.declaredType.name, label: attribute.declaredType.name }; } else { return null; } }, async (option: SelectOption): Promise&lt;BehaviorExecutionResult&gt; =&gt; { if (!!option) { attribute.declaredType = PiElementReference.create&lt;AttributeType&gt;( EntityEnvironment.getInstance().scoper.getFromVisibleElements(attribute, option.label, &quot;AttributeType&quot;) as AttributeType, &quot;Type&quot; ); } else { attribute.declaredType = null; } return BehaviorExecutionResult.EXECUTED; } ) ] ); . Here, we use a HorizontalListBox to show the attribute name, followed by a colon, followed by its type. . Step 3 - Allow Creation of New Elements . The projection sofar is exactly that: a projection. There are no actions defined yet, which we need to enable the user to change the model and add elements to it. First of all take a look at the built-in default behavior of the editor: . Inside a TextBox the text can be edited. . | Using the arrow keys the user can navigate the projection. . | Using Ctrl-Arrow the user can navigate up and down the model/AST. . | When an element is selected, it can be deleted with the DEL key. . | . The default behavior takes care of changing simple AST nodes and deleting both simple and complex AST nodes. But what about adding an element, e.g. adding a new attribute to an Entity. For this, we need to define an action coupled to an AliasBox. (From Actions you will have learned that an AliasBox is a predefined box where the user can type text to trigger some action.) . First we add an AliasBox to the projection of the attribute list. Note the role of the box: end-of-attribute-list. . Code Sample 9. Add AliasBox to Attribute List new VerticalListBox(entity,&quot;attributes&quot;, entity.attributes.map(att =&gt; { return this.getBox(att); }) ).addChild(new AliasBox(entity, &quot;end-of-attribute-list&quot;, &quot;add attribute&quot;)) . Then we create the actual action and attach it to the role of the AliasBox. . Code Sample 10. Attach Create Attribute Action to AliasBox { trigger: &quot;attribute&quot;, (2) activeInBoxRoles: [&quot;end-of-attribute-list&quot;], (1) action: (box: Box, trigger: PiTriggerType, editor: PiEditor): PiElement | null =&gt; { (3) var entity: Entity = box.element as Entity; const attribute: AttributeWithLimitedType = new AttributeWithLimitedType(); entity.attributes.push(attribute); return attribute; }, boxRoleToSelect: &quot;Attribute-name&quot; (4) }, . 1 | The action is attached to each box with the role &quot;end-of-attribute-list&quot;. | . 2 | The action will be triggered when the user types &quot;attribute&quot; inside the.alias box. | . 3 | The executable code for the action. It creates a new EntityEntity and attaches is to the EntityModel | . 4 | The focus of the editor is returned to the Box with the role &quot;attribute-name&quot; within the entity. This ensures that the user can immediately start typing the name of the entity after it has been created. | . There can be many boxes with the same role in the editor, as long as their model element is different. This way, the above action is available for each attribute list in each entity. . Define your own Actions . Tbis section needs to be written. See Defining Actions .",
    "url": "http://localhost:4000/version-0.1.0/pages/third-level/framework-tutorial.html",
    "relUrl": "/version-0.1.0/pages/third-level/framework-tutorial.html"
  }
  ,"18": {
    "title": "Getting Started",
    "content": "Getting Started with ProjectIt . To become familiar with ProjectIt, please, read the following pages in order. . Installation . | Project Structure . | Calling the Generator . | Adapting the Generated Pi-tools . |",
    "url": "http://localhost:4000/version-0.1.0/pages/starting/getting_started_intro.html",
    "relUrl": "/version-0.1.0/pages/starting/getting_started_intro.html"
  }
  ,"19": {
    "title": "ProjectIt - Introduction",
    "content": "ProjectIt&#8201;&#8212;&#8201;A Projectional Editor for the Web . ProjectIt is a Language Workbench (&#8230;&#8203;in the making :-) ). It is a tool for creating mini-languages, which are also known as Domain Specific Languages (DSLs). ProjectIt is able to generate an integrated set of editor, scoper, typer, and validator for your mini-language from a small set of definitions. . The core of ProjectIt is a TypeScript/JavaScript framework for building web-based, projectional editors. Editing expressions in a projectional editor is a well-known challenge. What makes the ProjectIt framework unique is the fact that it has built-in support for expressions, so you can easily make a projectional editor that allows for a natural manner of editing. . On top of the core framework there are five generators, each of which generates part of the work environment for your mini-language: . The language structure defines all the concept, properties and relationships in the language. . | The editor defines how a model in the language looks like on the screen. It also defines what editing commands can be used to change the model. . | The scoper defines how names that refer to other elements are being resolved. . | The typer defines what the type of an element is. . | The validator defines what a correct model looks like and wil provide errors whenever a model breaks these rules. . | . Currently, ProjectIt does not support the creation of debuggers, interpreters, generators, and such. Indeed, we have a (large) wish list of extra features that we would like to implement in the future. In some cases,like e.g code generators, we think that integration with existing tools is the best solution. In other cases we plan to provide ProjectIt components for specific functionality. Given time, we hope to realize many of these extra items. If you want to know why we have chosen this development route, read our statement on the philosophy behind the tool. . We assume that people that want to use ProjectIt know the basic about making mini-languages. For instance, the terms metamodel, abstract syntax tree, etc, should be familiar. When we address the ProjectIt user we call him or her a language engineer. The people that will be using the generated editor and its environment are simply called users. . So welcome, language engineer, to the world of ProjectIt. In this website you can find information on many subjects. You could .. . .. start by finding out what projectional editing is. . | .. see how you can install and use ProjectIt. . | .. find out how to define a language and its editor, etc. in the tutorials. . | .. dive deeper into the structure of the generated code. . | .. get to know more about the meta-code of ProjectIt. . | . Have fun! If you have questions that are not answered in this documentation, please email us at info AT projectit.org. .",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  ,"20": {
    "title": "Installing and Using ProjectIt",
    "content": "Installing and Using ProjectIt . Be sure to have node.js and yarn running. We are typically using the latest versions of all, although older versions likely work just as well. You could also try and use NPM instead of yarn. . There are two ways to start with ProjectIt, either use our Example project or use our Template project. . Start with the Example Project . The simplest manner to start working with ProjectIt is to clone the example project from github. In the following the root of your project will be indicated with &#39;~&#39;. . Clone branch master from https://github.com/projectit-org/ProjectIt-example. (For an explanation of the content of the project see source code organisation.) . | Next, install all necessary packages by running: yarn install . | Run the generator and see the generated files appearing in the folder ~/src/picode: yarn generate . | Start the server (note that anything that is saved in the editor will be stored in ~/modelstore): yarn model-server . | Open another (bash) terminal, and start the generated editor from it: yarn start . This command opens your preferred browser with the generated editor for the language Entity on http://localhost:3000/. If Chrome is not your preferred browser, please open the above page in Chrome, because we cannot ensure that the editor functions as it should in other browsers. . We are sorry to say that webpack is usually slow, particurlarly around 10% of the inital building. Don&#8217;t worry, just wait a bit longer. . | Try out the editor . If you are having trouble using the editor, have a look at the key-bindings under the Help menu. . | . Start with the Template project . Another way to start working with ProjectIt is to clone our template project from github. The template project provides a shell for the generated editor that enables the user to work with multiple models and model units. In the following the root of the project will be indicated with &#39;~&#39;. . Clone branch master from https://github.com/projectit-org/ProjectIt-template. (For an explanation of the content of the project see source code organisation.) . | Next, install all necessary packages by running: yarn install . | Create a folder for your language in ~/src, to hold the definition files for your language. We usually call it defs, but any name will do. (Here the name defs will be used.) . | Create a language definition file which defines the structure of your language. The extension of this file must be .ast. You can, for instance, copy EntityLanguage.ast from the ProjectIt example to your own defs-folder. Or, you can follow the tutorial on language structure definition. . To start with, you only need to define the language structure, defaults will be generated for the editor, scoper, typer, and validator. . | Next, adjust the scripts entry in the package.json file. The generate script should include your defs folder and the folder where you want the generated code to be stored. In the following screenshot, we use ~/src/defs and ~/src/picode, respectively. . | . Figure 1. Screenshot of package.json Run the generator and see the generated files appearing in the folder where you decided to store the generated code (in the screenshot we use ~/src/picode): yarn generate . | Adjust the configuration of the web application by changing the two lines in the file ~/src/webapp/WebappConfiguration.ts. . | . Figure 2. Screenshot of WebappConfiguration Start the server (note that anything that is saved in the editor will be stored in ~/modelstore): yarn model-server . | Open another (bash) terminal, and start the generated editor from it: yarn start . This command opens your preferred browser with the generated editor for your language on http://localhost:3000/. If Chrome is not your preferred browser, please open the above page in Chrome, because we cannot ensure that the editor functions as it should in other browsers. . We are sorry to say that webpack is usually slow, particurlarly around 10% of the inital building. Don&#8217;t worry, just wait a bit longer. . | Try out the editor . If you are having trouble using the editor, have a look at the key-bindings under the Help menu. . | . Next steps . Now you are ready for a closer look at ProjectIt. You can for instance: . Have a look at how the example language is defined by browsing through the language definition files in the ProjectIt Example project. You can find them in ~/src/defs, . | Or, follow our tutorials to create your own language, . | Have a look at the source code organisation of the generated project, . | See what the different options are for calling the ProjectIt generator. . | .",
    "url": "http://localhost:4000/version-0.1.0/pages/starting/installing.html",
    "relUrl": "/version-0.1.0/pages/starting/installing.html"
  }
  ,"21": {
    "title": "Language Structure",
    "content": "The Language Structure Definition . The abstract syntax tree (AST) of the language is described in files with the extension .ast. . Concepts . The ProjectIt language structure, which describes the abstarct syntax tree (AST), consists of a list of a Model, Model Units, Concepts, Expression Concepts, Limited Concepts and/or Interfaces. . Model . A model is the complete description specified by the user. The model is the root of the abstract syntax tree. It may hold any number of model units as children. These model units may be of different type. For instance, you can have model units that define the items in a home automation system, and other model units that define the rules that apply in this system. . model EntityModel { name: string; units: EntityModelUnit[]; extraUnit: SomeOtherModelUnit; } . Model unit . A model unit is a part of the model that can be edited independently from the rest of the model. A model unit is always a direct child of a model. The name of a model unit must always be public. . modelunit EntityModelUnit { public name: string; functions: EntityFunction[]; entities: Entity[]; } . Concept . A concept is the basic element of your language definition. It defines which instances can be present in a model created by your users. Concepts may extend one other concept, and implement multiple interfaces. . concept Entity implements Type { attributes: AttributeWithLimitedType[]; entAttributes: AttributeWithEntityType[]; functions: EntityFunction[]; reference baseEntity: Entity; } . Expression Concept . An expression concept is a concept that is an expression. The editor will deal with these differently in order to give your user a more natural editing experience. Note that expression concepts need to have a priority. Expression concepts may extend one other concept, and implement multiple interfaces. . binary expression MultiplyExpression base BinaryExpression { priority = 8; } . Limited Concept . A limited concept is a concept that has a limited number of predefined instances. Actually, it is an extended version of an enumeration. These instances become part of the standard library of your language. A limited concept must always have a name, but if this is not provided in the definition then it is automatically created. Furthermore, when a predefined instance does not provide a value for the name, the name of the instance is used. In this manner, you can define simple enumerations. . Limited concepts may extend one other concept, and implement multiple interfaces. . limited AttributeType implements BaseType { // if the &#39;name&#39; property was not provided, it would have been generated name: string; extra: number; String = { name: &quot;String&quot;, &quot;extra&quot;: 199} // notations &#39;name:&#39; and &#39;&quot;name&quot;:&#39; are both correct Integer = { &quot;name&quot;: &quot;Integer&quot;, &quot;extra&quot;: 240261} Boolean = { name: &quot;Boolean&quot;, &quot;extra&quot;: 5479} // the following instance gets the name &quot;ANY&quot; ANY = { &quot;extra&quot;: 456} } limited MockEnumeration { EnumValue1; EnumValue2; EnumValue3; } . Interface . An interface is a concept that has no instances. . interface Type base BaseType { simpleprop: string; int_attrs: AttributeWithLimitedType[]; int_functions: EntityFunction[]; reference baseInterface: Entity; } . Properties . Each of the language structure elements have Properties, of which there are the following three types. . Simple properties have as type string, number, or boolean, and are always contained in its concept. Simple properties may also be lists of string, number, or boolean. . | . concept EntityFunction { name: string; aliases: string[]; } . Parts have as type one of the concepts (including expression concepts and limited concepts) in the language, and are contained in the concept that holds the property (as in the UML composition relationship). Note that simple properties are always considered to be parts. . | . modelunit EntityModelUnit { functions: EntityFunction[]; entities: Entity[]; } . References also have as type one of the concepts in the language, but a reference is not contained in its concept (as in the UML association relationship). References are always by name, therefore the referred concect must have a name property of type string. . | . concept AttributeWithLimitedType { reference declaredType: AttributeType; } . Optional Properties . Properties may be optional. This is indicated using a question mark after the property name. . interface BaseType { name: string; baseInterface_attr?: number; } .",
    "url": "http://localhost:4000/version-0.1.0/pages/second-level/langdef-tutorial.html",
    "relUrl": "/version-0.1.0/pages/second-level/langdef-tutorial.html"
  }
  ,"22": {
    "title": "Under the Hood",
    "content": "Under the Hood . Before you dive deeper under the hood of this project, we invite you to read about the philosophy (and design guidelines) used during the creation of this tool. . With these in mind, you are welcome to find out more, for example on the following subjects. . Learn about the framework used for projectional editing. . | See how you can define custom projections and actions. . | Find out more about the build-in support for expressions. . | Explore why we use name based references. . | Note how the generated code is easily extendable using the ProjectIt interfaces. . | Browse through the source code documentation. . | .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/meta-documentation-intro.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/meta-documentation-intro.html"
  }
  ,"23": {
    "title": "Models and Model Units",
    "content": "Models and Model Units . Contrary to what is common in the world of Domain Specific Languages (DSLs) we believe that a model is often too large to handle. When dealing with source code, the times have long gone that a complete application was written in a single file. Since the 1980s every self-respecting programming language has supported some kind of modularization. It is our strong conviction that this approach should also be taken when dealing with models. . Similar to how the source code for a single application is split into classes and/or modules, every model in ProjectIt is split into model units. Each model may contain units of multiple types, either an array of units, or a single unit. . model EntityModel { name: string; units: EntityModelUnit[]; extraUnit: SomeOtherModelUnit; } . In the above example, an EntityModel consists of any number of entityModelUnit&#39;s and one SomeOtherModelUnit. . The notion of model units has been around for some time. At Eclipse Summit 2008 Modeling Symposium model units are introduced in Big Models an Alternative Approach. Earlier model units are described under the term Partial Models at the ECMDA-FA 2007 conference in Building a Flexible Software Factory Using Partial Domain Specific Models. More recently model units have been used within the Mendix meta-model to allow for working with large models in their web based modeling tools. This was presented at Splash 2016 Making Mendix Meta Model Driven. . Model Unit Interfaces . Another essential idea that we borrow from programming is information hiding. Every model unit in ProjectIt defines an interface. The interface determines which elements from the model unit are visible (i.e can be referred to) to other units in the same model. . In the projectIt definition of the language structure, or AST, concepts and properties can be defined to be public. Only these public parts of a model unit can be referenced from another model unit. The default scoper (the one from level 1) already takes the difference between public and private concepts and properties into account when resolving references. . Note that the language designer defines which elements in a model are referrable. From the point of view of the user this is a given part of the language he is using. This is similar to restrictions in a programming language that state that only certain types of elements may be exported/imported. . Note that references are by name, like they are in programming languages. This is unlike many other modeling environments, where references are done by id. .",
    "url": "http://localhost:4000/version-0.1.0/pages/intro/modelunits.html",
    "relUrl": "/version-0.1.0/pages/intro/modelunits.html"
  }
  ,"24": {
    "title": "Name-Based References",
    "content": "Name-Based References . In Support for Expressions we explain that editing expressions is a known challenge for projectional editors. A second challenge is posed by references, which is stated in Efficiency of Projectional Editing: A Controlled Experiment as follows. . References. References are based on pointers to the targetnode’s ID. Despite some advantages (e.g., robust refactorings) of this approach, we observe problems with the tradeoff that the reference target has to exist at the time the reference is created. A more robust and intuitive handling of references is desirable. While some problems can be solved by language developers (e.g., quick fixes to create reference targets), there should be a better way to support references by the IDE itself. . The approach to references in ProjectIt is to used only name-based references which are resolve on a need-to basis. . &#8212; Markus Voelter a.o. Efficiency of Projectional Editing All References are Name-Based . In ProjectIt we allow only name-based references. Every reference is an instance of PiElementReference, which holds: . the name of the referred element . | the meta-type of the referred element . | a cache of the element itself . | This means that the AST is truly a tree, not a graph. . The advantage is that we are not obliged to have the complete model in memory. Our use of multi-file models is explained in Models and Model Units. .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/name-based-references.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/name-based-references.html"
  }
  ,"25": {
    "title": "PiNamedElement",
    "content": "PiNamedElement . An object that implements PiNamedElement can be a node in a model AST, similar to PiElement implementations. The difference is that PiNamedElements have a name property. . export interface PiNamedElement extends PiElement { name: string; } .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/interfaces/named-element-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/interfaces/named-element-interface.html"
  }
  ,"26": {
    "title": "ProjectIt Philosophy",
    "content": "ProjectIt Philosophy . The design filosophy that we follow in ProjectIt can best be described by the following quote from Alan Kay . Simple things should be simple, complex things should be possible &#8212; Alan Kay The Pareto Principle . ProjectIt is a minimal viable product which supports the language engineer in creating a work environment for a mini-language. A key principle is the Pareto principle (or 80%-20% rule), which states that for many events, roughly 80% of the effects come from 20% of the causes. For example, it is an axiom of business management that &quot;80% of sales come from 20% of clients&quot;. . In language development the Pareto principle translates to “80% of the development effort is spend on 20% of the application”, this 20% being the more complex parts. Still, the other 80% of the application needs to be created as well. ProjectIt aims to make the latter as simple as possible, while keeping the generated code open for the language engineer to code the more complex parts by hand. One of our use cases is the creation of a prototype language in a day or in a couple of days at most. . Other Guidelines . Other guidelines have been ease of use, and flexibility. ProjectIt may not (yet :-)) do everything you need, but what it does, should be very easy to get into. Furthermore, ProjectIt is designed to be extendable, and easy to integrate with other tooling. Every part of the work environment that is generated, can be taken out and, provided the right interface is implemented, be exchanged for one that suits the language engineer better. Every part of the work environment is made by its own generator, so you can adjust which parts you do and do not want to generate. With our choice for TypeScript as base language, we believe that it will be possible for the different parts of the work environment to run on either the server or the client. Thus creating multiple deployment options. . With these principles in mind, we have started of small and simple. Every definition language, from the language structure to the validation rules, is kept minimal. Over time, in an agile fashion, these will be extended whenever the need arises. Furthermore, we want to use bootstrapping to create editors for every one of the definition languages. If you are interested, you can check out our wish list of features to be developed in the future. .",
    "url": "http://localhost:4000/version-0.1.0/pages/intro/philosophy.html",
    "relUrl": "/version-0.1.0/pages/intro/philosophy.html"
  }
  ,"27": {
    "title": "PiProjection",
    "content": "PiProjection . The projection from your model/AST is defined by implementing the PiProjection interface: . export interface PiProjection { /** * returns the box for `element`. */ getBox(element: PiElement): Box; rootProjection: PiProjection; name: string; } . Implementing this interface should return a Box for each element in the AST. ProjectIt includes boxes of various types (textual, tabular, horizontal or vertical collections, etc.) to define this projection. The box model is further described in the editor framework. .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/interfaces/projection-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/interfaces/projection-interface.html"
  }
  ,"28": {
    "title": "What is Projectional Editing?",
    "content": "What is Projectional Editing? . The essential characteristic of projectional editing is that the user manipulates the Abstract Syntax Tree (AST) directly, instead of the tradional manner in which the user manipulates a text (string), which is then parsed into a (changed) AST. For a generic view on projectional editing see wikipedia. . The overall flow in a projectional editor generated by ProjectIt is as follows: . The model/AST is mapped to a visual presentation (the projection). . | The projection is shown to the user. . | The user performs an action on the projection. . | The action on the projection is mapped to an action on the model/AST. . | (or 1 again) The changed model/AST is (re)mapped to a visual representation. . | Figure 1. General flow of projectional editing Typical user actions are to create a new element in the AST, to change the content of an element, or to delete an element. . Certainly, these changes may need to be persisted. When the user triggers the actions save or open the AST is pushed to or retrieved from a server. . Figure 2. Extra flow for save and open",
    "url": "http://localhost:4000/version-0.1.0/pages/intro/projectional-editing.html",
    "relUrl": "/version-0.1.0/pages/intro/projectional-editing.html"
  }
  ,"29": {
    "title": "PiReader",
    "content": "PiReader . An object that implements PiReader is able to read a string representation of a node in the AST. . If you want to write your own parser/filereader you will need to implement this interface. . export interface PiReader { /** * Reads the contents of the file located at &#39;filepath&#39; and * parses this content into a model unit of type &#39;metatype&#39;. * May throw an Error if the file cannot be found, or if a syntax error * occurs. * @param filepath * @param metatype */ // TODO readFromFile(filepath: string, metatype: string): PiElement; /** * Parses the &#39;input&#39; into a model unit of type &#39;metatype&#39;. * May throw an Error if a syntax error occurs. * @param input * @param metatype */ readFromString(input: string, metatype: string): PiElement; } .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/tools-interfaces/reader-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/tools-interfaces/reader-interface.html"
  }
  ,"30": {
    "title": "Scoper Definition",
    "content": "The Scoper Definition . For now, the scoper definition does not support our three-level approach. You can manually code your own scoper on the 3rd level, but it is not possible to combine this with the scopers on the 1st and 2nd levels. . This tutorial describes the possibilities of defining a scoper in the scoper definition file (with extension .scope). . In the scoper definition you provide the information necessary to determine which names are visible from a certain element of your user&#8217;s model. . Namespaces . In the scoper definition you can mark a list of concepts to be namespaces. Any namespace has its own set of visible names. Any namespace shadows the visible names from its surrounding namespace (using lexical scope). The default scoper simply regards the model of your user as the only namespace. . isnamespace { EntityModelUnit, Entity, EntityFunction } . Interfaces can be namespaces as well. Any instance of a concept that implements the namespace interface is a namespace, but only the properties of the interface will be visible. . Namespace Additions . The standard namespaces can be added to. In that case, the visible elements from the addition are included. By indicating an addition to a namespace you can, for instance, support inheritance. In the following example, baseEntity is in the language structure definition (.ast file) defined to be the super type of the Entity concept. The names visible in the baseEntity are included in the namespace by defining the namespace-addition. . Entity { namespace_addition = self.baseEntity; } . Alternative Scopes . You can also indicate that a different namespace altogether should be used. In the following example, the elements visible in an AppliedFeature are determined based on the type of its container, i.e. the type of its parent in the AST. . AppliedFeature { scope = typeof( container ); } .",
    "url": "http://localhost:4000/version-0.1.0/pages/second-level/scopedef-tutorial.html",
    "relUrl": "/version-0.1.0/pages/second-level/scopedef-tutorial.html"
  }
  ,"31": {
    "title": "PiScoper",
    "content": "PiScoper . An object that implements PiScoper is able to return the named elements that are visible for a certain AST node. This node can be a &#39;normal&#39; model element or it can be a namespace. If the node is a &#39;normal&#39; element, the names visbible in its (lexical) surrounding namespace are returned. . If you want to write your own scoper you will need to implement this interface. . export interface PiScoper { /** * Returns the element to which the &#39;pathname&#39; refers. If the elment cannot be found, or if the element is * not visible (private) from the location of &#39;modelelement&#39;, then null is returned. * If present, then the search is limited to elements which type is &#39;metatype&#39;. * * @param modelelement * @param pathname * @param metatype */ resolvePathName(modelelement: PiElement, pathname: string[], metatype?: string): PiNamedElement; /** * Returns true if &#39;name&#39; is known in the namespace containing &#39;modelelement&#39; or one * of its surrounding namespaces. * * When parameter &#39;metatype&#39; is present, it returns true if the element named &#39;name&#39; * is an instance of &#39;metatype&#39;. There is no default setting for this parameter. * * When parameter &#39;excludeSurrounding&#39; is present, it returns true if the element named &#39;name&#39; * is known in the namespace containing &#39;modelelement&#39;, without looking in surrounding namespaces. * * @param modelElement * @param name * @param metatype * @param excludeSurrounding */ isInScope(modelElement: PiElement, name: string, metatype?: string, excludeSurrounding?: boolean): boolean; /** * Returns all elements that are visible in the namespace containing &#39;modelelement&#39; or one * of its surrounding namespaces. * * When parameter &#39;metatype&#39; is present, it returns all elements that are an instance of &#39;metatype&#39;. * There is no default setting for this parameter. * * When parameter &#39;excludeSurrounding&#39; is present, it returns all elements that are visible in * the namespace containing &#39;modelelement&#39;, without looking in surrounding namespaces. Elements in * surrounding namespaces are normally shadowed by elements with the same name in an inner namespace. * * @param modelelement * @param metatype * @param excludeSurrounding */ getVisibleElements(modelelement: PiElement, metatype?: string, excludeSurrounding?: boolean): PiNamedElement[]; /** * Returns the element named &#39;name&#39; which is visible in the namespace containing &#39;modelelement&#39; or one * of its surrounding namespaces. * * When parameter &#39;metatype&#39; is present, it returns the element that is an instance of &#39;metatype&#39;. * There is no default setting for this parameter. * * When parameter &#39;excludeSurrounding&#39; is present, it returns the element that is visible in * the namespace containing &#39;modelelement&#39;, without looking in surrounding namespaces. Elements in * surrounding namespaces are normally shadowed by elements with the same name in an inner namespace. * * @param modelelement * @param name * @param metatype * @param excludeSurrounding */ getFromVisibleElements(modelelement: PiElement, name: string, metatype?: string, excludeSurrounding?: boolean): PiNamedElement; /** * Does the same as getVisibleElements, only it does not return the elements, * but the names of the elements. * * @param modelelement * @param metatype * @param excludeSurrounding */ getVisibleNames(modelelement: PiElement, metatype?: string, excludeSurrounding?: boolean): string[]; } .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/tools-interfaces/scoper-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/tools-interfaces/scoper-interface.html"
  }
  ,"32": {
    "title": "Customization of the Scoper",
    "content": "Third Level Customization of the Scoper . The scoper can not yet be customized per concept. Instead, you can replace the whole scoper by one create yourself. The new scoper needs to implement the following interface. . export interface PiScoper { /** * Returns the element to which the &#39;pathname&#39; refers. If the elment cannot be found, or if the element is * not visible (private) from the location of &#39;modelelement&#39;, then null is returned. * If present, then the search is limited to elements which type is &#39;metatype&#39;. * * @param modelelement * @param pathname * @param metatype */ resolvePathName(modelelement: PiElement, pathname: string[], metatype?: string): PiNamedElement; /** * Returns true if &#39;name&#39; is known in the namespace containing &#39;modelelement&#39; or one * of its surrounding namespaces. * * When parameter &#39;metatype&#39; is present, it returns true if the element named &#39;name&#39; * is an instance of &#39;metatype&#39;. There is no default setting for this parameter. * * When parameter &#39;excludeSurrounding&#39; is present, it returns true if the element named &#39;name&#39; * is known in the namespace containing &#39;modelelement&#39;, without looking in surrounding namespaces. * * @param modelElement * @param name * @param metatype * @param excludeSurrounding */ isInScope(modelElement: PiElement, name: string, metatype?: string, excludeSurrounding?: boolean): boolean; /** * Returns all elements that are visible in the namespace containing &#39;modelelement&#39; or one * of its surrounding namespaces. * * When parameter &#39;metatype&#39; is present, it returns all elements that are an instance of &#39;metatype&#39;. * There is no default setting for this parameter. * * When parameter &#39;excludeSurrounding&#39; is present, it returns all elements that are visible in * the namespace containing &#39;modelelement&#39;, without looking in surrounding namespaces. Elements in * surrounding namespaces are normally shadowed by elements with the same name in an inner namespace. * * @param modelelement * @param metatype * @param excludeSurrounding */ getVisibleElements(modelelement: PiElement, metatype?: string, excludeSurrounding?: boolean): PiNamedElement[]; /** * Returns the element named &#39;name&#39; which is visible in the namespace containing &#39;modelelement&#39; or one * of its surrounding namespaces. * * When parameter &#39;metatype&#39; is present, it returns the element that is an instance of &#39;metatype&#39;. * There is no default setting for this parameter. * * When parameter &#39;excludeSurrounding&#39; is present, it returns the element that is visible in * the namespace containing &#39;modelelement&#39;, without looking in surrounding namespaces. Elements in * surrounding namespaces are normally shadowed by elements with the same name in an inner namespace. * * @param modelelement * @param name * @param metatype * @param excludeSurrounding */ getFromVisibleElements(modelelement: PiElement, name: string, metatype?: string, excludeSurrounding?: boolean): PiNamedElement; /** * Does the same as getVisibleElements, only it does not return the elements, * but the names of the elements. * * @param modelelement * @param metatype * @param excludeSurrounding */ getVisibleNames(modelelement: PiElement, metatype?: string, excludeSurrounding?: boolean): string[]; } . Adjusting the Environment . Next you need to tell ProjectIt to use this new scoper instead of the generate one. You do this by changing the line that initializes the scoper in the class &lt;yourLanguageName&gt;Environment. You can find it in ~/picode/environment/. Obviously, you need to exchange &lt;yourLanguageName&gt; by the name of the language that you are creating. . Suppose the class YourScoper holds the scoper with the improvements that you have made, then the entry in the environment class would be: . export class EntityEnvironment implements PiEnvironment { ... scoper: PiScoper = new YourScoper(); ... } .",
    "url": "http://localhost:4000/version-0.1.0/pages/third-level/scoper-third-level.html",
    "relUrl": "/version-0.1.0/pages/third-level/scoper-third-level.html"
  }
  ,"33": {
    "title": "PiStdlib",
    "content": ":page-layout: _auto :imagesdir: ../../images :page-nav_order: 10 :page-parent: The Pi-tool Interfaces :page-grand_parent: Under the Hood :nav_exclude: true :src-dir: ../../../../../core/src :source-language: javascript :listing-caption: Code Sample = PiStdlib . An object that implements PiStdlib holds a number of predefined AST nodes, which can be referred to in the model AST. . If you want to write your own standard library you will need to implement this interface. . [source] . include::{src-dir}/stdlib/PiStdlib.ts[tag=stdlib-interface] —- .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/tools-interfaces/standardlib-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/tools-interfaces/standardlib-interface.html"
  }
  ,"34": {
    "title": "Third Level Customization",
    "content": ":page-layout: _auto :page-title: Third Level Customization :page-nav_order: 60 :page-has_children: true :page-has_toc: false :imagesdir: ../../images/ :src-dir: ../../../src/tutorial-language/defs :source-language: javascript :listing-caption: Code Sample = Third Level Customization . Please, become acquainted with the xref:../intro/three-levels.adoc[Three levels to Customize ProjectIt] used by ProjectIt. This section explains the 3rd of these three levels where you can customize ProjectIt in TypeScript.. . == Customize a Pi-tool Third level full adaptability per concept is currently possible for: . xref:./editor-third-level.adoc[Editor] | xref:./validator-third-level.adoc[Validator] | . To add third level adaptability for both scoper and typer is one of the entries in our xref:../intro/wish-list.adoc[wish list]. . == Replacing a Pi-tool All parts can be completely replaced at the 3rd level, thereby completely disregarding the 1st and 2nd level.. This is done by implementing their respective interfaces. . For the scoper and typer this is currently the only way to customize. . xref:./typer-third-level.adoc[typer] | xref:./scoper-third-level.adoc[scoper] | . == Pi-tool Interfaces . xref:../meta-documentation/tools-interfaces/scoper-interface.adoc[PiScoper] | xref:../meta-documentation/tools-interfaces/typer-interface.adoc[PiTyper] | xref:../meta-documentation/tools-interfaces/validator-interface.adoc[PiValidator] | xref:../meta-documentation/tools-interfaces/reader-interface.adoc[PiReader] | xref:../meta-documentation/tools-interfaces/writer-interface.adoc[PiWriter] | xref:../meta-documentation/tools-interfaces/standardlib-interface.adoc[PiStdlib] | .",
    "url": "http://localhost:4000/version-0.1.0/pages/third-level/third-level-intro.html",
    "relUrl": "/version-0.1.0/pages/third-level/third-level-intro.html"
  }
  ,"35": {
    "title": "Three Levels to Customize ProjectIt",
    "content": ":page-layout: _auto :imagesdir: ../../images :page-nav_order: 50 :page-title: Three Levels to Customize ProjectIt :page-parent: ProjectIt - Introduction :src-dir: ../../../src/tutorial-language/defs :projectitdir: ../../../core :source-language: javascript :listing-caption: Code Sample :icons: font [[levels]] = Three Levels to Customize ProjectIt . From the five parts of the language definition ProjectIt generates a workbench containing an editor, scoper, typer, and validator, and some utilities like a parser/deparser. All of these are separate components that are called pi-tools. . You, the language engineer, can fine-tune the generated pi-tools at several levels. We call this manner of fine-tuning: working at three levels. This three-level approach makes it possible to create your language, and customize it step-by-step in an agile fashion. (Read our xref:../intro/philosophy.adoc[philosophy] to understand why we have choosen these levels.) . Keeping in mind the quote from Alan Kay Simple things should be simple, complex things should be possible, we use the following levels of customization. . ==== [#three-levels] .Three level customization image::three-levels.png[three level customization] ==== . . On the first level, based solely on the metamodel definition in the AST, defaults are generated for every part of the workbench. For instance, the default scoper simply finds that every name in a model is visible everywhere. At this level you already have a fully working environment for your language. . Of course the defaults will look rather rough. On the second level, the other definitions (in the .edit, .scope, .valid, and .type files) are taken into account. When a definition for the editor, for instance, is present, it is used to generate a more suitable solution. The presentation in the editor could be more concise, using certain keywords etc. More on how to utilize the second level can be found in our xref:../second-level/tutorials-intro.adoc[tutorials]. . The third level takes hand-coding in TypeScript, but produces a result that is extremely adjusted to your needs. More on how to use the third level can be found in the tutorial on xref:../third-level/framework-tutorial.adoc[Using the Framework]. . ProjectIt combines definitions at each level into one application, where the third level precedes the second, and the second level precedes the first. For instance, the generated editor will per xref:../second-level/langdef-tutorial.adoc#concept[concept] in the language: . . use the hand-made projection from level 3, when this is present. If not, the editor will . use the projection generated from the editor definition from level 2, when this definition is present. Finally, when no definition is present, the editor will . use the default projection from level 1, the one generated when no .edit definition file is present. . This allows the language engineer to start quickly with a working (but some what rough) language environment and piece by piece refine this on either the second or the third level. . At the time of writing this approach is implemented for the editor and validator, in future this will also apply to the scoper and typer. .",
    "url": "http://localhost:4000/version-0.1.0/pages/intro/three-levels.html",
    "relUrl": "/version-0.1.0/pages/intro/three-levels.html"
  }
  ,"36": {
    "title": "The Pi-tool Interfaces",
    "content": ":page-layout: _auto :imagesdir: ../../images :page-nav_order: 55 :page-title: The Pi-tool Interfaces :page-parent: Under the Hood :page-has_children: true :src-dir: ../../../../../core/src :source-language: javascript :listing-caption: Code Sample = The Pi-tool Interfaces . There are two series of interfaces that make ProjectIt and its generated code extensible and flexible. The first series are the interfaces implemented by the generated code: . . xref:environment-interface.adoc[PiEnvironment] . xref:scoper-interface.adoc[PiScoper] . xref:validator-interface.adoc[PiValidator] . xref:typer-interface.adoc[PiTyper] . xref:reader-interface.adoc[PiReader] . xref:writer-interface.adoc[PiWriter] . xref:standardlib-interface.adoc[PiStdlib] . The second series of interfaces are those that define parts of the xref:../interfaces/core-interfaces-intro.adoc[core of the ProjectIt framework]. .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/tools-interfaces/tools-interfaces-intro.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/tools-interfaces/tools-interfaces-intro.html"
  }
  ,"37": {
    "title": "Tutorials",
    "content": ":page-layout: _auto :page-title: Tutorials :page-nav_order: 40 :page-has_children: true :imagesdir: ../../images/ :src-dir: ../../../src/tutorial-language/defs :source-language: javascript :listing-caption: Code Sample :page-has_toc: false = Tutorials – Second Level Language Definitions . Please, become acquainted with the xref:../intro/three-levels.adoc[three levels of language definitions] used by ProjectIt. This section explains the second of these three levels. . [[def-files]] == The Five Definition Files The second level of a ProjectIt language definition can have five parts: . . xref:langdef-tutorial.adoc[The language structure], or abstract syntax tree (AST) is defined in files with extension .ast. . xref:editdef-tutorial.adoc[The concrete syntax] of the language (CST), or editor definition, is defined in files with extension .edit. . xref:scopedef-tutorial.adoc[The scoping] is defined in files with extension .scope. . xref:typedef-tutorial.adoc[The typing] is defined in files with extension .type. . xref:validdef-tutorial.adoc[The validation] is defined in files with extension .valid. . And yes, you can use multiple files to define one of the parts. For instance, ProjectIt will combine multiple .ast files into one AST definition. . == The Example . In all tutorials we will be using the Entity language as example. The gist of the Entity language is that it defines serveral EntityModelUnits, each of which holds Entities and Functions. Entities can hold Properties and can hold Functions too. Every Function has a list of Parameters and an Expression. . ==== [#img-package-json] .UML diagram of Entity Language image::example-uml-diagram.png[uml-diagram-of-demo-language] ==== . We are working on a few other examples. You can find them in the development branch of link:https://github.com/projectit-org/ProjectIt[ProjectIt, window=_blank]. .",
    "url": "http://localhost:4000/version-0.1.0/pages/second-level/tutorials-intro.html",
    "relUrl": "/version-0.1.0/pages/second-level/tutorials-intro.html"
  }
  ,"38": {
    "title": "Typer Definition",
    "content": ":page-layout: _auto :page-title: Typer Definition :page-nav_order: 40 :page-parent: Tutorials :imagesdir: ../images/ :src-dir: ../../../src/tutorial-language/defs :source-language: javascript :listing-caption: Code Sample = The Typer Definition . For now, the typer definition does not support our xref:../intro/three-levels.adoc[three-level approach]. You can manually code your own scoper on the 3rd level, but it is not possible to combine this with the scopers on the 1st and 2nd levels. . This tutorial describes the possibilities of defining a typer in the typer definition file (with extension .type). . In the typer definition you provide the information necessary to do type checking. . == Types First, you have to indicate which concepts are considered to be types in your language. . Note that we assume that either there is a concept that is the common super type of all types in your language, or all types in your language implement the same interface. The first concept or interface in the types list is considered to be this root of your type hierarchy. [source] —- include::{src-dir}/LanguageDefinition.type[tag=types] —- . == Inference Rules . Using inference rules, you can indicate how to determine the type of certain concepts. Every concept for which an inference rule is defined has a type and that type is determined according to the given rule. In the following example the type of an entity function is the value of its attribute ‘declaredType’. Note that in the AST declaredType has (meta)type AttributeType, which has in the above example been stated to be a type in your user’s language. [source] —- include::{src-dir}/LanguageDefinition.type[tag=inference] —- . By stating that an inference rule is abstract, you define that the concept does have a type, but the way its type is determined, is given by the inference rules of its subconcepts. [source] —- include::{src-dir}/LanguageDefinition.type[tag=abstract] —- . == Type Conformance Rules Finally, you have to state your type conformance rules. In both inference and conformance rules it is possible to use the predefined instances of a limited concept. [source] —- include::{src-dir}/LanguageDefinition.type[tag=conformance] —- . == Rules that Apply to any Concept Conformance and other rules can also be defined to apply to any concept. Obviously, this means that any instance of any concept conforms to the given value. [source] —- include::{src-dir}/LanguageDefinition.type[tag=anytype] —- .",
    "url": "http://localhost:4000/version-0.1.0/pages/second-level/typedef-tutorial.html",
    "relUrl": "/version-0.1.0/pages/second-level/typedef-tutorial.html"
  }
  ,"39": {
    "title": "PiTyper",
    "content": ":page-layout: _auto :imagesdir: ../../images :page-nav_order: 10 :page-parent: The Pi-tool Interfaces :page-grand_parent: Under the Hood :nav_exclude: true :src-dir: ../../../../../core/src :source-language: javascript :listing-caption: Code Sample = PiTyper . An object that implements PiTyper is answer a set of question concerning the type of a node in the AST. . If you want to write your own typer you will need to implement this interface. . [source] . include::{src-dir}/typer/PiTyper.ts[tag=typer-interface] —- .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/tools-interfaces/typer-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/tools-interfaces/typer-interface.html"
  }
  ,"40": {
    "title": "Customization of the Typer",
    "content": ":page-layout: _auto :page-title: Customization of the Typer :page-nav_order: 50 :page-parent: Third Level Customization :imagesdir: ../images/ :src-dir: ../../../src/tutorial-language/ :source-language: javascript :listing-caption: Code Sample = Third Level Customization of the Typer . The typer can not yet be customized per concept. Instead, you can replace the whole typer by one create yourself. The new typer needs to implement the following interface. . [source] . include::../../../../core/src/typer/PiTyper.ts[tag=typer-interface] —- . == Adjusting the Environment Next you need to tell ProjectIt to use this new typer instead of the generate one. You do this by changing the line that initializes the typer in the class &lt;yourLanguageName&gt;Environment. You can find it in ~/picode/environment/. Obviously, you need to exchange &lt;yourLanguageName&gt; by the name of the language that you are creating. . Suppose the class YourTyper holds the typer with the improvements that you have made, then the entry in the environment class would be: . [source] . export class EntityEnvironment implements PiEnvironment { … typer: PiTyper = new YourTyper(); … } —- .",
    "url": "http://localhost:4000/version-0.1.0/pages/third-level/typer-third-level.html",
    "relUrl": "/version-0.1.0/pages/third-level/typer-third-level.html"
  }
  ,"41": {
    "title": "PiValidator",
    "content": ":page-layout: _auto :imagesdir: ../../images :page-nav_order: 10 :page-parent: The Pi-tool Interfaces :page-grand_parent: Under the Hood :nav_exclude: true :src-dir: ../../../../../core/src :source-language: javascript :listing-caption: Code Sample = PiValidator . An object that implements PiValidator is able to validate a node in the AST. The validation can be only on the node itself or it can include all child-nodes resursively. . The errors that are found are returned in the form of a list of PiError objects. Every PiError holds a message and a reference to the node that is faulty. . If you want to write your own validator you will need to implement this interface. . [source] . include::{src-dir}/validator/PiValidator.ts[tag=validator-interface] —- . == PiError . [source] . include::{src-dir}/validator/PiValidator.ts[tag=error-interface] —- .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/tools-interfaces/validator-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/tools-interfaces/validator-interface.html"
  }
  ,"42": {
    "title": "Customization of the Validator",
    "content": ":page-layout: _auto :page-title: Customization of the Validator :page-nav_order: 30 :page-parent: Third Level Customization :imagesdir: ../images/ :src-dir: ../../../src/tutorial-language/ :source-language: javascript :listing-caption: Code Sample = Third Level Customization of the Validator . The validator can be adjusted on level 3 by adding a single Typescript class. This class should implement the worker part of the visitor pattern, adding checks per node of the AST that is visited. . You can add the Typescript class anywhere, providing you let ProjectIt know where the file can be found through the ProjectIt configuration. See . == You own Validation Class . Create a Typescript file somewhere, for instance in ~/picode/validator. Note, again, to not add it to the ~/picode/validator/gen folder, as this will be delete upon regeneration. | Create a class in this file and let this class implement the generated &lt;yourLanguageName&gt;CheckerInterface. Obviously, &lt;yourLanguageName&gt; needs to be replaced by the name of your language. + This is the interface to be implemented for the language called Entity. [source] —- export interface EntityCheckerInterface extends EntityDefaultWorker { errorList: PiError[]; } —- [start=3] | Let your class extend the generated default AST worker part of the visitor pattern, which is called &lt;yourLanguageName&gt;DefaultWorker. | Now implement any of the methods of the default worker put in your validation the corresponding model element. This method will override the (empty) default implementation. The validation error should be pushed onto the errorList attribute. Therefore, each error must implement the xref:../meta-documentation/tools-interfaces/validator-interface.adoc#PiError[PiError] interface. | . The result of the above should look something like this: . [source] . include::{src-dir}/validator/CustomValidation.ts[tag=custom-validator] —- . In this example only nodes of type EntityFunction are checked. If the name of the node equals determine than an error is pushed on the errorList. . If you want the walker to stop when an erroneous node is found you should return true, else return false. . == The Configuration You should let ProjectIt know where it can find your customized validation class by adding an instance of your class to the customValidations array in the file ProjectitConfiguration.ts. You will find this file in ~/picode/projectit. It is generated once, and wil not be overwritten on regeneration. . Using the above example class, the configuration should look like this: . [source] . include::{src-dir}/projectit/ProjectitConfiguration.ts[tag=custom-validator] —- .",
    "url": "http://localhost:4000/version-0.1.0/pages/third-level/validator-third-level.html",
    "relUrl": "/version-0.1.0/pages/third-level/validator-third-level.html"
  }
  ,"43": {
    "title": "Validator Definition",
    "content": ":page-layout: _auto :page-title: Validator Definition :page-nav_order: 50 :page-parent: Tutorials :imagesdir: ../images/ :src-dir: ../../../src/tutorial-language/defs :source-language: javascript :listing-caption: Code Sample = The Validator Definition . == Three-level definition As explained in xref:../intro/three-levels.adoc#levels[Three-levels to Define your Pi-tools] the generated validator can be defined in three levels. For each concept in the AST the validator will . // TODO Doesn’t the validator comcine all three levels? . use the hand-made validation rule(s), when present. Otherwise the validator will . use to the validation rule(s) generated from the validator definition, when this definition is present. Finally, the validator will . use the xref:default[default validation rule(s)]. . The rest of this tutorial explains the second level: how to write a validator definition (.valid file). . == The Validator Definition File The validator definition defines the constraints that should be true in the models build by your users. Currently, there are four types of rules. . === Valid Identifier Rules . Given a simple property of type string, a valid-identifier-rule can be given. The property complies with the rule if it is a valid identifier according to the TypeScript definition. [indent=1] For a valid-identifier-rule the validIdentifier keyword is used followed by an optional simple property. When the property is present, this property is checked. When the property is not present, ProjectIt assumes that the concept has a simple property named ‘name’ of type ‘string’, and it will check this property. . [source] . include::{src-dir}/LanguageDefinition.valid[tag=valididentifier] —- . === Simple Value Rules Given a simple property, its value can be limited to certain values. [source] —- include::{src-dir}/LanguageDefinition.valid[tag=value] —- . === List Rules Given a list property, a not-empty rule can be stated. The list complies with the rule if it is not empty. . Given a list property, an is-unique rule can be stated on a property of the elements in the list. The list complies when the value of the property is unique for every element in the list. [source] —- include::{src-dir}/LanguageDefinition.valid[tag=lists] —- . === Type Check Rules Given the rules in the typer definition, rules can be stated to ensure type compliance. To indicate a type checking rule the keyword typecheck is used, followed by either equalsType or conformsTo. The first demands that the types of the two properties given are equal. The second demands that the type of the first conforms to the type of the second. . In the type checking rules it is possible to use predefined instances of a limited concept. [source] —- include::{src-dir}/LanguageDefinition.valid[tag=typecheck] —- . [[default]] == The Default Validation Rules . There are just a few default validation rules: . . Non optional properties must be set. . Non optional lists must include one element. . Names of model units should be valid identifiers. .",
    "url": "http://localhost:4000/version-0.1.0/pages/second-level/validdef-tutorial.html",
    "relUrl": "/version-0.1.0/pages/second-level/validdef-tutorial.html"
  }
  ,"44": {
    "title": "Future Developments",
    "content": ":page-layout: _auto :imagesdir: ../images/ :page-nav_order: 90 :page-title: Future Developments :page-parent: ProjectIt - Introduction :src-dir: ../../../core/src :projectitdir: ../../../core :source-language: javascript = Wish List for Future Developments . In the future we want to extend ProjectIt with the following features. There is no order in this list, nor is there any guarantee that the features will be build. We take on a task at the moment the need for it arises (or, simply when we like doing it). . Add the possibility in the validator definition for language engineers to state their own error messages with each rule, instead of using the predefined messages. | Allow for pathname references, i.e. references that are not a single name but a list of names (pathname). | Support libraries for language development, like a library with definitions for different types of expressions. | Third level adaptability per concept for both the scoper and typer. | Create an interpreter generator. | Provide a coupling to a model-to-model generator. | Add an importer for link:https://www.jetbrains.com/mps/[Jetbrains MPS, window=_blank] structure models. We already have a prototype based on the https://github.com/dslmeinte/mps-open-source/tree/master/mps-analyser[MPS Analyser] from Meinte Broersma. | Create a diagrammatic view of the language structure definition. | … | . If you are using ProjectIt, and are missing a specific feature, please let us know through info AT projectit.org. .",
    "url": "http://localhost:4000/version-0.1.0/pages/intro/wish-list.html",
    "relUrl": "/version-0.1.0/pages/intro/wish-list.html"
  }
  ,"45": {
    "title": "PiWriter",
    "content": ":page-layout: _auto :imagesdir: ../../images :page-nav_order: 10 :page-parent: The Pi-tool Interfaces :page-grand_parent: Under the Hood :nav_exclude: true :src-dir: ../../../../../core/src :source-language: javascript :listing-caption: Code Sample = PiWriter . An object that implements PiWriter is able to build a string representation of a node in the AST. . If you want to write your own unparser/writer you will need to implement this interface. . [source] . include::{src-dir}/writer/PiWriter.ts[tag=writer-interface] —- .",
    "url": "http://localhost:4000/version-0.1.0/pages/meta-documentation/tools-interfaces/writer-interface.html",
    "relUrl": "/version-0.1.0/pages/meta-documentation/tools-interfaces/writer-interface.html"
  }
  
}