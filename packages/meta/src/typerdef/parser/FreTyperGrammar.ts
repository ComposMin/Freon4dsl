// Generated by the ProjectIt Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by MetaTyperModelUnitReader

export const MetaTyperGrammarStr = `
namespace MetaTyperLanguage
grammar MetaTyperGrammar {
                
// rules for "TyperDef"
TyperDef = 'typer'
	 ( 'istype' '\{' [ __pi_reference / ',' ]* '}' )?
	 FretTypeConcept*
	 ( 'hastype' '\{' [ __pi_reference / ',' ]* '}' )?
	 FretAnyTypeSpec?
	 FretClassifierSpec* ;

FretTypeConcept = 'type' identifier ( 'base' __pi_reference )?
	 '\{'
	 ( FretProperty ';' )*
	 '}' ;

FretAnyTypeSpec = 'anytype' '\{'
	 FretTypeRule*
	 '}' ;

FretInferenceRule = 'infertype' FretExp ';' ;

FretPropertyCallExp = FretExp '.' __pi_reference ;

FretSelfExp = 'self' ;

FretAnytypeExp = 'anytype' ;

FretVarCallExp = __pi_reference ;

FretCreateExp = __pi_reference '\{' [ FretPropInstance / ',' ]* '}' ;

FretPropInstance = __pi_reference ':' FretExp ;

FretFunctionCallExp = identifier '(' [ FretExp / ',' ]* ')' ;

FretLimitedInstanceExp = ( __pi_reference ':' )?
	 __pi_reference ;

FretWhereExp = FretVarDecl 'where' '\{'
	 ( __pi_binary_FretExp ';' )*
	 '}' ;

FretVarDecl = identifier ':' __pi_reference ;

FretConformanceRule = 'conformsto' FretExp ';' ;

FretEqualsRule = 'equalsto' FretExp ';' ;

FretLimitedRule = FretExp ';' ;

FretClassifierSpec = __pi_reference '\{'
	 FretTypeRule*
	 '}' ;

FretTypeRule = FretInferenceRule 
    | FretConformanceRule 
    | FretEqualsRule 
    | FretLimitedRule  ;

FretExp = FretPropertyCallExp 
    | FretSelfExp 
    | FretAnytypeExp 
    | FretVarCallExp 
    | FretCreateExp 
    | FretLimitedInstanceExp 
    | FretWhereExp 
    | FretFunctionCallExp 
    | __pi_binary_FretExp ;

__pi_binary_FretExp = [FretExp / __pi_binary_operator]2+ ;
leaf __pi_binary_operator = 'conformsto' | 'equalsto' ;

FretProperty = identifier ':' __pi_reference ;

__pi_reference = [ identifier / '::' ]+ ;
        
// white space and comments
skip WHITE_SPACE = "\\s+" ;
skip SINGLE_LINE_COMMENT = "//[^\\r\\n]*" ;
skip MULTI_LINE_COMMENT = "/\\*[^*]*\\*+(?:[^*/][^*]*\\*+)*/" ;
        
// the predefined basic types   
leaf identifier          = "[a-zA-Z_][a-zA-Z0-9_]*" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = '"' "[^\\"\\\\]*(\\\\.[^\\"\\\\]*)*" '"' ;
leaf numberLiteral       = "[0-9]+";
leaf booleanLiteral      = 'false' | 'true';
            
}`; // end of grammar
