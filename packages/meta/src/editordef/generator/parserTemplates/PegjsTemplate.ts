import {
    PiClassifier,
    PiConcept,
    PiInterface,
    PiLanguage, PiLimitedConcept,
    PiPrimitiveProperty,
    PiProperty
} from "../../../languagedef/metalanguage/PiLanguage";
import { ListJoinType, PiEditConcept, PiEditProjectionText, PiEditSubProjection, PiEditUnit } from "../../metalanguage";
import { findAllImplementorsAndSubs, findImplementors, Helpers, Names } from "../../../utils";

export class PegjsTemplate {
    referredClassifiers: PiClassifier[] = [];
    textForListConcepts: string[] = [];
    listNumber: number = 0;

    generatePegjsForUnit(language: PiLanguage, langUnit: PiConcept, editDef: PiEditUnit): string {
        this.referredClassifiers = [];
        this.textForListConcepts = [];
        this.listNumber= 0;
        const creatorName = Names.parserCreator(language);

        // Note that the order in which the rules are stated, determines whether the parser is functioning or not
        // first create a rule for the unit, next for its children, etc.
        const sortedEditorDefs = this.findEditorDefsForUnit(langUnit, editDef.conceptEditors);

        // Template starts here, no prettier for pegjs files, therefore we take indentation into account in this template
        return `// Generated by the ProjectIt Language Generator.

// This file contains the input to the PEG.JS parser generator (see https://pegjs.org). The parser generator 
// is automatically called by the ProjectIt Language Generator and another file with the same name, but with
// extension ".js" is created. The ".js" file contains the actual parser.
// The file with extension ".pegjs" (this file) is stored in order for the parsing rules to be examined.

{
    let creator = require("./${creatorName}");
}
        
${sortedEditorDefs.map(conceptDef => `${this.makeConceptRule(conceptDef)}`).join("")}
${language.interfaces.map(intf => `${this.makeInterfaceRule(intf)}`).join("")}
${this.referredClassifiers.map(piClassifier => `${this.makeReferenceRule(piClassifier)}`).join("")}
${this.textForListConcepts.map(listRule => `${listRule}`).join("")}

ws "whitespace" = (([ \\t\\n\\r]) / (SingleLineComment) / (MultiLineComment) )*
rws "required whitespace" = (([ \\t\\n\\r]) / (SingleLineComment) / (MultiLineComment) )+

variable "variable"
  = first:varLetter rest:identifierChar* { return first + rest.join(""); }

stringLiteral       = "\\"" chars:anyChar* "\\"" { return chars.join(""); }

varLetter           = [a-zA-Z]
identifierChar      = [a-zA-Z0-9_$] // any char but not /.,!?@~%^&*-=+(){}"':;<>?[]\\/
anyChar             = [*a-zA-Z0-9' /\\-[\\]+<>=#$_.,!?@~%^&*-=+(){}:;<>?]
number              = [0-9]

numberLiteral     = nums:number+ { return nums.join(""); }
booleanLiteral    = fbool:"false" \ tbool:"true" { if (!!fbool) { return fbool; } else { return tbool; } }

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)*

LineTerminator
  = [\\n\\r\\u2028\\u2029]

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

SourceCharacter
  = .
  
char
  = unescaped
  / escape
    sequence:(
        '"'
      / "\\\\"
      / "/"
      / "\\["
      / "\\]"
      / "$"
      / "b" { return "\\b"; }
      / "f" { return "\\f"; }
      / "n" { return "\\n"; }
      / "r" { return "\\r"; }
      / "t" { return "\\t"; }
      / "u" digits:$(HEXDIG HEXDIG HEXDIG HEXDIG) {
          return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return sequence; }

escape
  = "\\\\"

unescaped
  = [^\\0-\\x1F\\x22\\x5C]

// ----- Core ABNF Rules -----

// See RFC 4234, Appendix B (http://tools.ietf.org/html/rfc4234).
DIGIT  = [0-9]
HEXDIG = [0-9a-f]
`;
        // end Template
    }

    private makeConceptRule(conceptDef: PiEditConcept): string {
        // TODO extend this for interfaces, AFTER the editDefinition is adjusted
        const piClassifier: PiConcept = conceptDef.concept.referred;
        if (piClassifier.isModel) return ``;

        const propsToSet: PiProperty[] = [];

        conceptDef.projection.lines.forEach(l => {
            l.items.forEach(item => {
                if (item instanceof PiEditSubProjection) {propsToSet.push(item.expression.findRefOfLastAppliedFeature())}
            });
        });

        // TODO escape all quotes in a text string
        return `${Names.classifier(piClassifier)} = ${conceptDef.projection.lines.map(l => 
            `${l.items.map(item => 
                `${(item instanceof PiEditProjectionText)? 
                    `\"${item.text.trim()}\" ws ` 
                    : 
                    `${(item instanceof PiEditSubProjection)? 
                        `${this.makeSubProjectionRule(item)} ws `
                        : 
                        `` }` 
            }`).join("")}`
        ).join("\n\t")}\n\t{ return creator.create${piClassifier.name}({${propsToSet.map(prop => `${prop.name}:${prop.name}`).join(", ")}}); }\n\n`;
    }

    private makeSubProjectionRule(item: PiEditSubProjection): string {
        const myElem = item.expression.findRefOfLastAppliedFeature();
        if (myElem.isList) {
            this.listNumber++;
            let listRuleName: string;
            if (myElem instanceof PiPrimitiveProperty) {
                listRuleName = Names.startWithUpperCase(myElem.primType) + "List" + this.listNumber;
            } else {
                if (item.listJoin?.joinType === ListJoinType.Separator) {
                    listRuleName = Names.startWithUpperCase(myElem.type.referred.name) + "List" + this.listNumber;
                } else {
                    listRuleName = Names.startWithUpperCase(myElem.type.referred.name);
                }
            }

            if (item.listJoin?.joinType === ListJoinType.Separator) {
                this.makeRuleForList(item, myElem, listRuleName);
                return `${myElem.name}:${listRuleName} ws `;
            } else {
                if (!myElem.isPart) {
                    listRuleName += "Reference";
                    if (!this.referredClassifiers.includes(myElem.type.referred)) {
                        this.referredClassifiers.push(myElem.type.referred);
                    }
                }
                return `${myElem.name}:(${listRuleName} ws "${item.listJoin?.joinText}" ws)* `;
            }
        } else {
            if (myElem instanceof PiPrimitiveProperty) {
                if (myElem.name === "name") {
                    return `${myElem.name}:variable`;
                }
                switch (myElem.primType) {
                    case "string":
                        return `${myElem.name}:stringLiteral ws`;
                    case "boolean":
                        return `${myElem.name}:booleanLiteral ws`;
                    case "number":
                        return `${myElem.name}:numberLiteral ws`;
                }
                return ``;
            } else {
                const typeName = myElem.type.referred.name;
                if (myElem.isPart) {
                    return `${myElem.name}:${typeName}`;
                } else { // the property is a reference
                    if (!this.referredClassifiers.includes(myElem.type.referred)) {
                        this.referredClassifiers.push(myElem.type.referred);
                    }
                    return `${myElem.name}:${typeName}Reference ws `;
                }
            }
        }
    }

    private makeReferenceRule(piClassifier: PiClassifier): string {
        return `${piClassifier.name}Reference = name:variable
    { return creator.create${piClassifier.name}Reference({name: name}); }\n\n`;
    }

    private makeRuleForList(item: PiEditSubProjection, myElem: PiProperty, listRuleName: string) {
        let typeName: string = '';
        if (myElem instanceof PiPrimitiveProperty) {
            // TODO add the boolean and number type
            // TODO make a difference between variables and stringLiterals
            typeName = "stringLiteral";
        } else {
            typeName = myElem.type.referred.name;
            if (!myElem.isPart) {
                typeName += "Reference";
                if (!this.referredClassifiers.includes(myElem.type.referred)) {
                    this.referredClassifiers.push(myElem.type.referred);
                }
            }
        }
        const joinText = item.listJoin?.joinText.trimRight();
        if (item.listJoin?.joinType === ListJoinType.Separator) {
            this.textForListConcepts.push(`${listRuleName} = head:${typeName} tail:("${joinText}" ws v:${typeName} { return v; })*
    { return [head].concat(tail); }\n\n`);
        }
    }

    private findPartConceptsInUnit(langUnit: PiConcept): PiConcept[] {
        let result: PiConcept[] = [];
        result.push(langUnit);
        this.addPartConcepts(langUnit, result);
        return result;
    }

    private addPartConcepts(langUnit: PiConcept, result: PiConcept[]) {
        langUnit.allParts().forEach(part => {
            const type = part.type.referred;
            if (!result.includes(type)) {
                result.push(type);
                this.addPartConcepts(type, result);
            }
        });
    }

    private findEditorDefsForUnit(langUnit: PiConcept, conceptEditors: PiEditConcept[]): PiEditConcept[] {
        let result : PiEditConcept[] = [];
        const unitConcepts = this.findPartConceptsInUnit(langUnit);
        // Again note that the order in which the rules are stated, determines whether the parser is functioning or not
        // first create a rule for the unit, next for its children, etc.
        unitConcepts.forEach(con => {
            result.push(...conceptEditors.filter(editor => editor.concept.referred == con));
        });
        return result;
    }

    private makeInterfaceRule(intf: PiInterface): string {
        // for interfaces we create a parse rule that is a choice between all classifiers that either implement or extend the interface
        // TODO should we include a reference to a limited concept in the parse rule for an interface?
        // because, limited concept can only be used as reference, these are excluded for this choice
        // we also need to filter out the interface itself
        const implementors = findAllImplementorsAndSubs(intf).filter(piCLassifier => (piCLassifier !== intf) && !(piCLassifier instanceof PiLimitedConcept));

        return `${intf.name} = 
     ${implementors.map((piClassifier, index) => `var${index}:${Names.classifier(piClassifier)} { return var${index}; }`).join("\n    / ")}\n\n`;
    }
}

