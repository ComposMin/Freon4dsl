import {
    PiBinaryExpressionConcept,
    PiClassifier,
    PiConcept,
    PiInterface,
    PiLanguage,
    PiLimitedConcept,
    PiPrimitiveProperty,
    PiProperty
} from "../../../languagedef/metalanguage";
import { ListJoin, ListJoinType, PiEditConcept, PiEditProjectionText, PiEditSubProjection, PiEditUnit } from "../../metalanguage";
import { findAllImplementorsAndSubs, findImplementors, Names } from "../../../utils";

export const referencePostfix = "PiElemRef";

// there is no prettier for pegjs files, therefore we take indentation and other layout matters into account in this template
// unfortunately, this makes things a little less legible :-(

export class PegjsTemplate {
    referredClassifiers: PiClassifier[] = [];
    textForListConcepts: string[] = [];
    listNumber: number = 0;

    generatePegjsForUnit(language: PiLanguage, langUnit: PiConcept, editDef: PiEditUnit): string {
        this.referredClassifiers = [];
        this.textForListConcepts = [];
        this.listNumber = 0;
        const creatorName = Names.parserCreator(language);

        // Note that the order in which the rules are stated, determines whether the parser is functioning or not
        // first create a rule for the unit, next for its children, etc.
        // the following method stores its result in two lists: one for all editor definitions found, one for all used interfaces
        const sortedEditorDefs: PiEditConcept[] = [];
        const sortedInterfaces: PiInterface[] = [];
        this.findEditorDefsForUnit(langUnit, editDef.conceptEditors, sortedEditorDefs, sortedInterfaces);

        // Template starts here, no prettier for pegjs files, therefore we take indentation into account in this template
        return `// Generated by the ProjectIt Language Generator.

// This file contains the input to the PEG.JS parser generator (see https://pegjs.org). The parser generator 
// is automatically called by the ProjectIt Language Generator and another file with the same name, but with
// extension ".js" is created. The ".js" file contains the actual parser.
// The file with extension ".pegjs" (this file) is stored in order for the parsing rules to be examined.

{
    let creator = require("./${creatorName}");
}
        
${sortedEditorDefs.map(conceptDef => `${this.makeConceptRule(conceptDef)}`).join("\n")}
${sortedInterfaces.length > 0 ? `${sortedInterfaces.map(intf => `${this.makeChoiceRule(intf)}`).join("\n")}` : `` }
${this.referredClassifiers.map(piClassifier => `${this.makeReferenceRule(piClassifier)}`).join("\n")}
${this.textForListConcepts.map(listRule => `${listRule}`).join("\n")}
ws "whitespace" = (([ \\t\\n\\r]) / (SingleLineComment) / (MultiLineComment) )*
rws "required whitespace" = (([ \\t\\n\\r]) / (SingleLineComment) / (MultiLineComment) )+

varLetter           = [a-zA-Z]
identifierChar      = [a-zA-Z0-9_$] // any char but not /.,!?@~%^&*-=+(){}"':;<>?[]\\/
anyChar             = [*a-zA-Z0-9' /\\-[\\]+<>=#$_.,!?@~%^&*-=+(){}:;<>?]
number              = [0-9]

variable            = first:varLetter rest:identifierChar* { return first + rest.join(""); }
stringLiteral       = "\\"" chars:anyChar* "\\"" { return chars.join(""); }
numberLiteral       = nums:number+ { return Number.parseInt(nums.join("")); }
booleanLiteral      = "false" { return false; }
                    / "true" { return true; }

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)*

LineTerminator
  = [\\n\\r\\u2028\\u2029]

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

SourceCharacter
  = .
  
char
  = unescaped
  / escape
    sequence:(
        '"'
      / "\\\\"
      / "/"
      / "\\["
      / "\\]"
      / "$"
      / "b" { return "\\b"; }
      / "f" { return "\\f"; }
      / "n" { return "\\n"; }
      / "r" { return "\\r"; }
      / "t" { return "\\t"; }
      / "u" digits:$(HEXDIG HEXDIG HEXDIG HEXDIG) {
          return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return sequence; }

escape
  = "\\\\"

unescaped
  = [^\\0-\\x1F\\x22\\x5C]

// ----- Core ABNF Rules -----

// See RFC 4234, Appendix B (http://tools.ietf.org/html/rfc4234).
DIGIT  = [0-9]
HEXDIG = [0-9a-f]
`;
        // end Template
    }

    private makeConceptRule(conceptDef: PiEditConcept): string {
        const piClassifier: PiConcept = conceptDef.concept.referred;
        if (piClassifier.isModel || piClassifier instanceof PiLimitedConcept) {
            return ``;
        }
        const myName = Names.classifier(piClassifier);
        if (piClassifier.isAbstract) {
            return this.makeChoiceRule(piClassifier);
        } else if (piClassifier instanceof PiBinaryExpressionConcept) {
            return this.makeBinaryExpressionRule(conceptDef, piClassifier);
        } else {
            const propsToSet: PiProperty[] = [];

            conceptDef.projection.lines.forEach(l => {
                l.items.forEach(item => {
                    if (item instanceof PiEditSubProjection) {
                        propsToSet.push(item.expression.findRefOfLastAppliedFeature());
                    }
                });
            });

            // TODO escape all quotes in a text string
            return `${myName} = ${conceptDef.projection.lines.map(l =>
                `${l.items.map(item =>
                    `${(item instanceof PiEditProjectionText) ?
                        `\"${item.text.trim()}\" ws `
                        :
                        `${(item instanceof PiEditSubProjection) ?
                            `${this.makeSubProjectionRule(item)} ws `
                            :
                            ``}`
                    }`).join("")}`
            ).join("\n\t")}\n\t{ return creator.create${myName}({${propsToSet.map(prop => `${prop.name}:${prop.name}`).join(", ")}}); }\n`;
        }
    }

    private makeSubProjectionRule(item: PiEditSubProjection): string {
        const myElem = item.expression.findRefOfLastAppliedFeature();
        if (myElem.isList) {
            this.listNumber++;
            let listRuleName: string;
            if (myElem instanceof PiPrimitiveProperty) {
                listRuleName = Names.startWithUpperCase(myElem.primType) + "List" + this.listNumber;
                // TODO remove this hack when the edit definition includes lists of primitives
                item.listJoin = new ListJoin();
                item.listJoin.joinText = ", ";
                item.listJoin.joinType = ListJoinType.Separator;
                // end hack
            } else {
                if (item.listJoin?.joinType === ListJoinType.Separator) {
                    listRuleName = Names.startWithUpperCase(myElem.type.referred.name) + "List" + this.listNumber;
                } else {
                    listRuleName = Names.startWithUpperCase(myElem.type.referred.name);
                }
            }

            if (item.listJoin?.joinType === ListJoinType.Separator) {
                this.makeRuleForList(item, myElem, listRuleName);
                return `${myElem.name}:${listRuleName} ws `;
            } else {
                if (!myElem.isPart) {
                    listRuleName += referencePostfix;
                    if (!this.referredClassifiers.includes(myElem.type.referred)) {
                        this.referredClassifiers.push(myElem.type.referred);
                    }
                }
                return `${myElem.name}:(${listRuleName} ws "${item.listJoin?.joinText}" ws)* `;
            }
        } else {
            if (myElem instanceof PiPrimitiveProperty) {
                if (myElem.name === "name") {
                    return `${myElem.name}:variable`;
                }
                switch (myElem.primType) {
                    case "string":
                        return `${myElem.name}:stringLiteral ws`;
                    case "boolean":
                        return `${myElem.name}:booleanLiteral ws`;
                    case "number":
                        return `${myElem.name}:numberLiteral ws`;
                }
                return ``;
            } else {
                const typeName = Names.classifier(myElem.type.referred);
                if (myElem.isPart) {
                    return `${myElem.name}:${typeName}`;
                } else { // the property is a reference
                    if (!this.referredClassifiers.includes(myElem.type.referred)) {
                        this.referredClassifiers.push(myElem.type.referred);
                    }
                    return `${myElem.name}:${typeName}${referencePostfix} ws `;
                }
            }
        }
    }

    private makeReferenceRule(piClassifier: PiClassifier): string {
        const myName = Names.classifier(piClassifier);
        return `${myName}${referencePostfix} = name:variable
    { return creator.create${myName}${referencePostfix}({name: name}); }\n`;
    }

    private makeRuleForList(item: PiEditSubProjection, myElem: PiProperty, listRuleName: string) {
        // the following test should have been performed before calling this method
        // we only need a separate rule for list with a separator, example:
        // VariableList = head:Variable tail:("separator" ws v:Variable { return v; })*
        // without separator we write, for example
        // SomeRule = ".. anything" (Variable "terminator")*
        if (item.listJoin?.joinType !== ListJoinType.Separator) {
            console.log("rejecting rule " + listRuleName);
            return;
        }
        // now make the rule
        // find the right typeName
        let typeName: string = "";
        if (myElem instanceof PiPrimitiveProperty) {
            // TODO make a difference between variables and stringLiterals
            switch (myElem.primType) {
                case "string": {
                    typeName = "stringLiteral";
                    break;
                }
                case "number": {
                    typeName = "numberLiteral";
                    break;
                }
                case "boolean": {
                    typeName = "booleanLiteral";
                    break;
                }
                default: typeName = "stringLiteral";
            }
        } else {
            typeName = Names.classifier(myElem.type.referred);
            if (!myElem.isPart) { // it is a reference, so use the rule for creating a PiElementReference
                typeName += referencePostfix;
                if (!this.referredClassifiers.includes(myElem.type.referred)) {
                    this.referredClassifiers.push(myElem.type.referred);
                }
            }
        }

        // create the right separator text
        const joinText = (item.listJoin?.joinText ? `${item.listJoin?.joinText.trimRight()}` : " ");

        // push the rule to the textForListConcepts to be added to the template later
        this.textForListConcepts.push(`${listRuleName} = head:${typeName} tail:("${joinText}" ws v:${typeName} { return v; })*
    { return [head].concat(tail); }\n`);
    }

    // this method returns a list of classifiers that are used as types of parts of 'piClassifier'
    // if the type of a part is an interface, all implementing concepts - direct, or through base interfaces -
    // are returned
    // if the type of a part is an abstract concept, all direct subconcepts are returned
    // 'typesDone' is a list of classifiers that are already examined
    private addPartConcepts(piClassifier: PiClassifier, result: PiClassifier[], typesDone: PiClassifier[]) {
        // make sure this classifier is not visited twice
        if (typesDone.includes(piClassifier)) {
            return;
        }
        typesDone.push(piClassifier);

        // include this classifier in the result
        if (!result.includes(piClassifier)) {
            result.push(piClassifier);
        }

        // see what else needs to be included
        if (piClassifier instanceof PiConcept) {
            if (!piClassifier.isAbstract) {
                // for non-abstract concepts include all types of parts
                piClassifier.allParts().forEach(part => {
                    const type = part.type.referred;
                    this.addPartConcepts(type, result, typesDone);
                });
            } else {
                // for abstract concepts include all direct subconcepts
                piClassifier.allSubConceptsDirect().forEach(type2 => {
                    this.addPartConcepts(type2, result, typesDone);
                });
            }
        } else if (piClassifier instanceof PiInterface) {
            // for interfaces include all implementors and subinterfaces
            findAllImplementorsAndSubs(piClassifier).forEach(type2 => {
                this.addPartConcepts(type2, result, typesDone);
            });
        }
    }

    private findEditorDefsForUnit(langUnit: PiConcept, conceptEditors: PiEditConcept[], result1: PiEditConcept[], result2: PiInterface[]) {
        const typesUsedInUnit = [];
        this.addPartConcepts(langUnit, typesUsedInUnit, []);
        // Again note that the order in which the rules are stated, determines whether the parser is functioning or not
        // first create a rule for the unit, next for its children, etc.
        typesUsedInUnit.forEach(type => {
            if (type instanceof PiConcept) {
                result1.push(...conceptEditors.filter(editor => editor.concept.referred === type));
            } else if (type instanceof PiInterface) {
                result2.push(type);
            }
        });
    }

    private makeChoiceRule(piClassifier: PiClassifier): string {
        // for interfaces we create a parse rule that is a choice between all classifiers that either implement or extend the interface
        // because limited concepts can only be used as reference, these are excluded for this choice
        // we also need to filter out the interface itself
        // the same is done for abstract concepts
        let implementors: PiClassifier[] = [];
        if (piClassifier instanceof PiInterface) {
            // TODO should we include a reference to a limited concept in the parse rule for an interface?
            implementors = findImplementors(piClassifier).filter(piCLassifier => !(piCLassifier instanceof PiLimitedConcept));
        } else if (piClassifier instanceof PiConcept) {
            implementors = piClassifier.allSubConceptsDirect().filter(piCLassifier => !(piCLassifier instanceof PiLimitedConcept));
        }

        if (implementors.length > 0 ) {
            return `${Names.classifier(piClassifier)} = ${implementors.map((implementor, index) =>
                `var${index}:${Names.classifier(implementor)} { return var${index}; }`).join("\n    / ")}\n`;
        } else {
            return `${Names.classifier(piClassifier)} = "ERROR: there are no concepts that implement this interface"\n`;
        }
    }

    private makeBinaryExpressionRule(conceptDef: PiEditConcept, piClassifier: PiBinaryExpressionConcept) {
        const left = piClassifier.allProperties().find(prop => prop.name === "left");
        const right = piClassifier.allProperties().find(prop => prop.name === "right");
        const leftRule = Names.classifier(left.type.referred);
        const rightRule = Names.classifier(right.type.referred);
        const symbol = conceptDef.symbol;
        const myName = Names.classifier(piClassifier);
        return `${myName} = "(" ws left:${leftRule} ws "${symbol}" ws right:${rightRule} ws ")"
    { return creator.create${myName}({left: left, right: right}); }
    `;
    }
}
