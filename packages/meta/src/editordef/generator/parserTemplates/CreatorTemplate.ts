import { PiConcept, PiInterface, PiLanguage, PiLimitedConcept, PiPrimitiveProperty } from "../../../languagedef/metalanguage";
import { PiEditUnit } from "../../metalanguage";
import { LANGUAGE_GEN_FOLDER, Names, STDLIB_GEN_FOLDER } from "../../../utils";
import { PiLangUtil } from "../../../languagedef/metalanguage";
import { referencePostfix } from "./PegjsTemplate";

export class CreatorTemplate {

    /**
     * Returns a string representation of a module that contains for every concept in
     * 'language' two functions: a create function and a create function for a reference to this concept.
     * These functions are used in the parser generated by pegjs.
     */
    public generateCreatorPart(language: PiLanguage, editDef: PiEditUnit, relativePath: string): string {
        const stdlibName = Names.stdlib(language);
        const imports = language.concepts.map(concept => Names.concept(concept))
            .concat(language.interfaces.map(intf => Names.interface(intf)));

        // Template starts here
        return `
        import { PiElementReference, ${imports.join(", ")} } from "${relativePath}${LANGUAGE_GEN_FOLDER }";     
        import { ${stdlibName} } from "${relativePath}${STDLIB_GEN_FOLDER}/${stdlibName}";
        
        const stdlib = ${stdlibName}.getInstance();
        
        class Name {
            name: string;
        }
                
        /**
        *   This file contains a number of functions that are used by the javascript parsers
        *   to create instances of the user model, i.e. nodes in the abstract syntax tree.
        */

        ${language.concepts.map(con => this.makeConceptFunctions(con)).join("\n")}
        ${language.interfaces.map(con => this.makeInterfaceFunctions(con)).join("\n")}
        `;
        // end Template
    }

    /**
     * Creates two exported functions for PiConcept 'con'. The first creates an instance of
     * class 'con', the second creates a PiElementReference to a concept of type 'con'.
     * @param con
     */
    private makeConceptFunctions(con: PiConcept): string {
        const conceptName: string = Names.concept(con);

        // check if the concept has a name property, otherwise we cannot create a reference function
        // we also do not create a reference for a modelunit, nor for a model
        const nameProperty: PiPrimitiveProperty = PiLangUtil.findNameProp(con);
        const addReferenceFunction: boolean = !(con.isModel || con.isUnit) && !!nameProperty;
        let referenceFunction: string = "";
        if (!!addReferenceFunction) {
            referenceFunction = `export function create${conceptName}${referencePostfix}(data: Name): PiElementReference<${conceptName}> {
                return PiElementReference.create<${conceptName}>(data.name, "${conceptName}");
            }
            `;
        }

        if (con.isAbstract || (con instanceof PiLimitedConcept)) {
            return `${addReferenceFunction ? `
            ${referenceFunction}` : ``}`;
        } else {
            return `export function create${conceptName}(data: Partial<${conceptName}>): ${conceptName} {
            return ${conceptName}.create(data);
        }        
        ${addReferenceFunction ? `
            ${referenceFunction}` : ``}`;
        }
    }

    /**
     * Creates one exported functions for PiInterface 'piInterface'. It creates a
     * PiElementReference to an object that implements 'piInterface'.
     * @param piInterface
     */
    private makeInterfaceFunctions(piInterface: PiInterface): string {
        const intfName: string = Names.interface(piInterface);

        // check if the concept has a name property, otherwise we cannot create a reference function
        const nameProperty: PiPrimitiveProperty = PiLangUtil.findNameProp(piInterface);
        const addReferenceFunction: boolean = !!nameProperty;
        if (!!addReferenceFunction) {
            return `export function create${intfName}${referencePostfix}(data: Name): PiElementReference<${intfName}> {
                return PiElementReference.create<${intfName}>(data.name, "${intfName}");
            }
            `;
        } else {
            return "";
        }
    }
}
