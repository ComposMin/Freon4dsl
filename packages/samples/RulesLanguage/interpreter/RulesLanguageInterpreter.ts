// Generated by the ProjectIt Language Generator.
import { InterpreterContext, IMainInterpreter } from "@projectit/core";
import {
    FunctionCall,
    Multiply,
    NumberLiteral,
    ParameterRef,
    Plus,
    RFunction,
    RuleExpression
} from "../language/gen/index";
import { RulesLanguageInterpreterBase } from "./gen/RulesLanguageInterpreterBase";

let main: IMainInterpreter;

export class RulesLanguageInterpreter extends RulesLanguageInterpreterBase {
    constructor(m: IMainInterpreter) {
        super();
        main = m;
    }

    override evalMultiply(node: Multiply, ctx: InterpreterContext): Object {
        const leftValue = main.evaluate(node.piLeft(), ctx) as Number;
        const rightValue = main.evaluate(node.piRight(), ctx) as Number;
        return new Number(leftValue.valueOf() * rightValue.valueOf());
    }

    override evalPlus(node: Plus, ctx: InterpreterContext): Object {
        // console.log("Execute Plus");
        const leftValue = main.evaluate(node.piLeft(), ctx) as Number;
        // console.log("Execute Plus left: " + leftValue);
        const rightValue = main.evaluate(node.piRight(), ctx) as Number;
        // console.log("Execute Plus right: " + rightValue);
        return new Number(leftValue.valueOf() + rightValue.valueOf());
    }

    override evalFunctionCall(node: FunctionCall, ctx: InterpreterContext): Object {
        const newContext = new InterpreterContext(ctx);
        node.arguments.forEach((argument: RuleExpression, index: number) => {
            const argValue = main.evaluate(argument, ctx);
            newContext.set(node.func.referred.parameters[index], argValue);
        });
        const result = main.evaluate(node.func.referred, newContext);
        return result;
    }

    override evalRFunction(node: RFunction, ctx: InterpreterContext): Object {
        const result = main.evaluate(node.body, ctx);
        // console.log("result of funccall is " + result)
        return result;
    }

    override evalParameterRef(node: ParameterRef, ctx: InterpreterContext): Object {
        const result = ctx.find(node.par.referred);
        // console.log("ParRef result is " + result)
        return result;
    }

    override evalNumberLiteral(node: NumberLiteral, ctx: InterpreterContext): Object {
        return new Number(node.value);;
    }
}
