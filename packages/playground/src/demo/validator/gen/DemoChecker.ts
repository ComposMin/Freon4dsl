// Generated by the ProjectIt Language Generator.
import { PiError, PiTyper } from "@projectit/core";
import {
    DemoModel,
    DemoEntity,
    DemoAttribute,
    DemoFunction,
    DemoVariable,
    DemoExpression,
    DemoPlaceholderExpression,
    DemoLiteralExpression,
    DemoStringLiteralExpression,
    DemoNumberLiteralExpression,
    DemoBooleanLiteralExpression,
    DemoAbsExpression,
    DemoBinaryExpression,
    DemoMultiplyExpression,
    DemoPlusExpression,
    DemoDivideExpression,
    DemoAndExpression,
    DemoOrExpression,
    DemoComparisonExpression,
    DemoLessThenExpression,
    DemoGreaterThenExpression,
    DemoEqualsExpression,
    DemoFunctionCallExpression,
    DemoIfExpression,
    DemoVariableRef,
    DemoAttributeType,
    DemoType
} from "../../language";
import { DemoUnparser } from "../../../demo/unparser/DemoUnparser";
import { DemoWorker } from "../../../demo/utils/gen/DemoWorker";

export class DemoChecker implements DemoWorker {
    myUnparser = new DemoUnparser();
    typer: PiTyper;
    errorList: PiError[] = [];

    public execDemoModel(modelelement: DemoModel) {
        // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(new PiError("'" + modelelement.name + "' is not a valid identifier", name));
        }
        // @notEmpty this.entities
        if (modelelement.entities.length == 0) {
            this.errorList.push(new PiError("List 'this.entities' may not be empty", modelelement.entities));
        }
        // @notEmpty this.functions
        if (modelelement.functions.length == 0) {
            this.errorList.push(new PiError("List 'this.functions' may not be empty", modelelement.functions));
        }
    }

    public execDemoEntity(modelelement: DemoEntity) {
        // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(new PiError("'" + modelelement.name + "' is not a valid identifier", name));
        }
        // @notEmpty this.attributes
        if (modelelement.attributes.length == 0) {
            this.errorList.push(new PiError("List 'this.attributes' may not be empty", modelelement.attributes));
        }
        // @notEmpty this.functions
        if (modelelement.functions.length == 0) {
            this.errorList.push(new PiError("List 'this.functions' may not be empty", modelelement.functions));
        }
    }

    public execDemoAttribute(modelelement: DemoAttribute) {
        // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(new PiError("'" + modelelement.name + "' is not a valid identifier", name));
        }
    }

    public execDemoFunction(modelelement: DemoFunction) {
        // @typecheck conformsTo( this.expression, this.declaredType )
        if (!this.typer.conformsTo(modelelement.expression, modelelement.declaredType)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.expression) +
                        "' does not conform to (the type of) '" +
                        this.myUnparser.unparse(modelelement.declaredType) +
                        "'",
                    modelelement.expression
                )
            );
        }
        // @notEmpty this.parameters
        if (modelelement.parameters.length == 0) {
            this.errorList.push(new PiError("List 'this.parameters' may not be empty", modelelement.parameters));
        }
        // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(new PiError("'" + modelelement.name + "' is not a valid identifier", name));
        }
    }

    public execDemoVariable(modelelement: DemoVariable) {
        // @validName name
        if (!this.isValidName(modelelement.name)) {
            this.errorList.push(new PiError("'" + modelelement.name + "' is not a valid identifier", name));
        }
    }

    public execDemoAbsExpression(modelelement: DemoAbsExpression) {
        // @typecheck equalsType( this.expr, DemoAttributeType:Integer )
        if (!this.typer.equalsType(modelelement.expr, DemoAttributeType.Integer)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.expr) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Integer) +
                        "'",
                    modelelement.expr
                )
            );
        }
    }

    public execDemoMultiplyExpression(modelelement: DemoMultiplyExpression) {
        // @typecheck equalsType( this.left, DemoAttributeType:Integer )
        if (!this.typer.equalsType(modelelement.left, DemoAttributeType.Integer)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.left) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Integer) +
                        "'",
                    modelelement.left
                )
            );
        }
        // @typecheck equalsType( this.right, DemoAttributeType:Integer )
        if (!this.typer.equalsType(modelelement.right, DemoAttributeType.Integer)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.right) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Integer) +
                        "'",
                    modelelement.right
                )
            );
        }
    }

    public execDemoPlusExpression(modelelement: DemoPlusExpression) {
        // @typecheck equalsType( this.left, DemoAttributeType:Integer )
        if (!this.typer.equalsType(modelelement.left, DemoAttributeType.Integer)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.left) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Integer) +
                        "'",
                    modelelement.left
                )
            );
        }
        // @typecheck equalsType( this.right, DemoAttributeType:Integer )
        if (!this.typer.equalsType(modelelement.right, DemoAttributeType.Integer)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.right) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Integer) +
                        "'",
                    modelelement.right
                )
            );
        }
        // @typecheck conformsTo( this.left, this.right )
        if (!this.typer.conformsTo(modelelement.left, modelelement.right)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.left) +
                        "' does not conform to (the type of) '" +
                        this.myUnparser.unparse(modelelement.right) +
                        "'",
                    modelelement.left
                )
            );
        }
    }

    public execDemoDivideExpression(modelelement: DemoDivideExpression) {
        // @typecheck equalsType( this.left, DemoAttributeType:Integer )
        if (!this.typer.equalsType(modelelement.left, DemoAttributeType.Integer)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.left) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Integer) +
                        "'",
                    modelelement.left
                )
            );
        }
        // @typecheck equalsType( this.right, DemoAttributeType:Integer )
        if (!this.typer.equalsType(modelelement.right, DemoAttributeType.Integer)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.right) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Integer) +
                        "'",
                    modelelement.right
                )
            );
        }
    }

    public execDemoAndExpression(modelelement: DemoAndExpression) {
        // @typecheck equalsType( this.left, DemoAttributeType:Boolean )
        if (!this.typer.equalsType(modelelement.left, DemoAttributeType.Boolean)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.left) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Boolean) +
                        "'",
                    modelelement.left
                )
            );
        }
        // @typecheck equalsType( this.right, DemoAttributeType:Boolean )
        if (!this.typer.equalsType(modelelement.right, DemoAttributeType.Boolean)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.right) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Boolean) +
                        "'",
                    modelelement.right
                )
            );
        }
    }

    public execDemoOrExpression(modelelement: DemoOrExpression) {
        // @typecheck equalsType( this.left, DemoAttributeType:Boolean )
        if (!this.typer.equalsType(modelelement.left, DemoAttributeType.Boolean)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.left) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Boolean) +
                        "'",
                    modelelement.left
                )
            );
        }
        // @typecheck equalsType( this.right, DemoAttributeType:Boolean )
        if (!this.typer.equalsType(modelelement.right, DemoAttributeType.Boolean)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.right) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Boolean) +
                        "'",
                    modelelement.right
                )
            );
        }
    }

    public execDemoComparisonExpression(modelelement: DemoComparisonExpression) {
        // @typecheck equalsType( this.left, this.right )
        if (!this.typer.equalsType(modelelement.left, modelelement.right)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.left) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(modelelement.right) +
                        "'",
                    modelelement.left
                )
            );
        }
    }

    public execDemoIfExpression(modelelement: DemoIfExpression) {
        // @typecheck equalsType( this.condition, DemoAttributeType:Boolean )
        if (!this.typer.equalsType(modelelement.condition, DemoAttributeType.Boolean)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.condition) +
                        "' should be equal to (the type of) '" +
                        this.myUnparser.unparse(DemoAttributeType.Boolean) +
                        "'",
                    modelelement.condition
                )
            );
        }
        // @typecheck conformsTo( this.whenTrue, this.whenFalse )
        if (!this.typer.conformsTo(modelelement.whenTrue, modelelement.whenFalse)) {
            this.errorList.push(
                new PiError(
                    "Type of '" +
                        this.myUnparser.unparse(modelelement.whenTrue) +
                        "' does not conform to (the type of) '" +
                        this.myUnparser.unparse(modelelement.whenFalse) +
                        "'",
                    modelelement.whenTrue
                )
            );
        }
    }

    public execDemoExpression(modelelement: DemoExpression) {}

    public execDemoPlaceholderExpression(modelelement: DemoPlaceholderExpression) {}

    public execDemoLiteralExpression(modelelement: DemoLiteralExpression) {}

    public execDemoStringLiteralExpression(modelelement: DemoStringLiteralExpression) {}

    public execDemoNumberLiteralExpression(modelelement: DemoNumberLiteralExpression) {}

    public execDemoBooleanLiteralExpression(modelelement: DemoBooleanLiteralExpression) {}

    public execDemoBinaryExpression(modelelement: DemoBinaryExpression) {}

    public execDemoLessThenExpression(modelelement: DemoLessThenExpression) {}

    public execDemoGreaterThenExpression(modelelement: DemoGreaterThenExpression) {}

    public execDemoEqualsExpression(modelelement: DemoEqualsExpression) {}

    public execDemoFunctionCallExpression(modelelement: DemoFunctionCallExpression) {}

    public execDemoVariableRef(modelelement: DemoVariableRef) {}

    private isValidName(name: string): boolean {
        if (name == null) return false;
        // cannot start with number
        if (/[0-9]/.test(name[0])) return false;
        // may contain letters, numbers, '$', and '_', but no other characters
        if (/[.|,|!|?|@|~|%|^|&|*|-|=|+|(|)|{|}|"|'|:|;|<|>|?]/.test(name)) return false;
        if (/\\/.test(name)) return false;
        if (/[/|[|]]/.test(name)) return false;
        // may not contain whitespaces
        if (/[\t|\n|\r| ]/.test(name)) return false;
        // may not be a Typescript keyword
        // TODO implement this
        return true;
    }
}
