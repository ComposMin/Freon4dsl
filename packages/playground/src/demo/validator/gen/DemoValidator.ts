// Generated by the ProjectIt Language Generator.
import { AllDemoConcepts } from "../../language";
import { PiValidator, PiError, PiTyper } from "@projectit/core";
import { DemoConceptType } from "../../language/Demo";
import {
    DemoModel,
    DemoEntity,
    DemoAttribute,
    DemoFunction,
    DemoVariable,
    DemoExpression,
    DemoPlaceholderExpression,
    DemoLiteralExpression,
    DemoStringLiteralExpression,
    DemoNumberLiteralExpression,
    DemoBooleanLiteralExpression,
    DemoAbsExpression,
    DemoBinaryExpression,
    DemoMultiplyExpression,
    DemoPlusExpression,
    DemoDivideExpression,
    DemoAndExpression,
    DemoOrExpression,
    DemoComparisonExpression,
    DemoLessThenExpression,
    DemoGreaterThenExpression,
    DemoEqualsExpression,
    DemoFunctionCallExpression,
    DemoIfExpression,
    DemoVariableRef
} from "../../language";
import { DemoChecker } from "./DemoChecker";

export class DemoValidator implements PiValidator {
    myTyper: PiTyper;

    public validate(modelelement: AllDemoConcepts, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];

        if (modelelement instanceof DemoModel) {
            result.concat(this.validateDemoModel(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoEntity) {
            result.concat(this.validateDemoEntity(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoAttribute) {
            result.concat(this.validateDemoAttribute(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoFunction) {
            result.concat(this.validateDemoFunction(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoVariable) {
            result.concat(this.validateDemoVariable(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoExpression) {
            result.concat(this.validateDemoExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoPlaceholderExpression) {
            result.concat(this.validateDemoPlaceholderExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoLiteralExpression) {
            result.concat(this.validateDemoLiteralExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoStringLiteralExpression) {
            result.concat(this.validateDemoStringLiteralExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoNumberLiteralExpression) {
            result.concat(this.validateDemoNumberLiteralExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoBooleanLiteralExpression) {
            result.concat(this.validateDemoBooleanLiteralExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoAbsExpression) {
            result.concat(this.validateDemoAbsExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoBinaryExpression) {
            result.concat(this.validateDemoBinaryExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoMultiplyExpression) {
            result.concat(this.validateDemoMultiplyExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoPlusExpression) {
            result.concat(this.validateDemoPlusExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoDivideExpression) {
            result.concat(this.validateDemoDivideExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoAndExpression) {
            result.concat(this.validateDemoAndExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoOrExpression) {
            result.concat(this.validateDemoOrExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoComparisonExpression) {
            result.concat(this.validateDemoComparisonExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoLessThenExpression) {
            result.concat(this.validateDemoLessThenExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoGreaterThenExpression) {
            result.concat(this.validateDemoGreaterThenExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoEqualsExpression) {
            result.concat(this.validateDemoEqualsExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoFunctionCallExpression) {
            result.concat(this.validateDemoFunctionCallExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoIfExpression) {
            result.concat(this.validateDemoIfExpression(modelelement, includeChildren));
        }
        if (modelelement instanceof DemoVariableRef) {
            result.concat(this.validateDemoVariableRef(modelelement, includeChildren));
        }

        return result;
    }

    public validateDemoModel(modelelement: DemoModel, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoModel(modelelement, this.myTyper));

        if (!(includeChildren === undefined) && includeChildren) {
            modelelement.entities.forEach(p => {
                result.concat(this.validateDemoEntity(p, includeChildren));
            });
            modelelement.functions.forEach(p => {
                result.concat(this.validateDemoFunction(p, includeChildren));
            });
        }

        return result;
    }

    public validateDemoEntity(modelelement: DemoEntity, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoEntity(modelelement, this.myTyper));

        if (!(includeChildren === undefined) && includeChildren) {
            modelelement.attributes.forEach(p => {
                result.concat(this.validateDemoAttribute(p, includeChildren));
            });
            modelelement.functions.forEach(p => {
                result.concat(this.validateDemoFunction(p, includeChildren));
            });
        }

        return result;
    }

    public validateDemoAttribute(modelelement: DemoAttribute, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoAttribute(modelelement, this.myTyper));

        return result;
    }

    public validateDemoFunction(modelelement: DemoFunction, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoFunction(modelelement, this.myTyper));

        if (!(includeChildren === undefined) && includeChildren) {
            result.concat(this.validateDemoExpression(modelelement.expression, includeChildren));
            modelelement.parameters.forEach(p => {
                result.concat(this.validateDemoVariable(p, includeChildren));
            });
        }

        return result;
    }

    public validateDemoVariable(modelelement: DemoVariable, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoVariable(modelelement, this.myTyper));

        return result;
    }

    public validateDemoExpression(modelelement: DemoExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoExpression(modelelement, this.myTyper));

        return result;
    }

    public validateDemoPlaceholderExpression(modelelement: DemoPlaceholderExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoPlaceholderExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoLiteralExpression(modelelement: DemoLiteralExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoLiteralExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoStringLiteralExpression(modelelement: DemoStringLiteralExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoStringLiteralExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoLiteralExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoNumberLiteralExpression(modelelement: DemoNumberLiteralExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoNumberLiteralExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoLiteralExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoBooleanLiteralExpression(modelelement: DemoBooleanLiteralExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoBooleanLiteralExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoLiteralExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoAbsExpression(modelelement: DemoAbsExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoAbsExpression(modelelement, this.myTyper));

        if (!(includeChildren === undefined) && includeChildren) {
            result.concat(this.validateDemoExpression(modelelement.expr, includeChildren));
        }

        // check rules of baseconcept(s)
        result.concat(this.validateDemoExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoBinaryExpression(modelelement: DemoBinaryExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoBinaryExpression(modelelement, this.myTyper));

        if (!(includeChildren === undefined) && includeChildren) {
            result.concat(this.validateDemoExpression(modelelement.left, includeChildren));
            result.concat(this.validateDemoExpression(modelelement.right, includeChildren));
        }

        // check rules of baseconcept(s)
        result.concat(this.validateDemoExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoMultiplyExpression(modelelement: DemoMultiplyExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoMultiplyExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoBinaryExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoPlusExpression(modelelement: DemoPlusExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoPlusExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoBinaryExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoDivideExpression(modelelement: DemoDivideExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoDivideExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoBinaryExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoAndExpression(modelelement: DemoAndExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoAndExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoBinaryExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoOrExpression(modelelement: DemoOrExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoOrExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoBinaryExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoComparisonExpression(modelelement: DemoComparisonExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoComparisonExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoBinaryExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoLessThenExpression(modelelement: DemoLessThenExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoLessThenExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoComparisonExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoGreaterThenExpression(modelelement: DemoGreaterThenExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoGreaterThenExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoComparisonExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoEqualsExpression(modelelement: DemoEqualsExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoEqualsExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoComparisonExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoFunctionCallExpression(modelelement: DemoFunctionCallExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoFunctionCallExpression(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoIfExpression(modelelement: DemoIfExpression, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoIfExpression(modelelement, this.myTyper));

        if (!(includeChildren === undefined) && includeChildren) {
            result.concat(this.validateDemoExpression(modelelement.condition, includeChildren));
            result.concat(this.validateDemoExpression(modelelement.whenTrue, includeChildren));
            result.concat(this.validateDemoExpression(modelelement.whenFalse, includeChildren));
        }

        // check rules of baseconcept(s)
        result.concat(this.validateDemoExpression(modelelement, includeChildren));
        return result;
    }

    public validateDemoVariableRef(modelelement: DemoVariableRef, includeChildren?: boolean): PiError[] {
        let result: PiError[] = [];
        result.concat(new DemoChecker().checkDemoVariableRef(modelelement, this.myTyper));

        // check rules of baseconcept(s)
        result.concat(this.validateDemoExpression(modelelement, includeChildren));
        return result;
    }
}
