// This file contains the grammar for the ProjectIt Example project
// which is input to the AGL parser.
// It is a transformed version of the grammar that is generated by ProjectIt.
// Any errors could be either in the generation, the transformation to AGL format, or ...



export const ExModelGrammarStr: string = `
namespace test
grammar PiExample {

ExModel = 'model' identifier '{' Entity* 'model' 'wide' 'Methods:' Method* '}' ;

Entity = 'Entity' identifier _OptionalBaseEntity? '{' Attribute* Method* '}' ;

_OptionalBaseEntity = 'base' EntityPiElemRef ;

Attribute = identifier ':' TypePiElemRef;

Method = 'method' identifier '(' [Parameter / ',']* '):' TypePiElemRef '{' ExExpression '}' ;

Parameter = identifier  ':'  TypePiElemRef;

ExExpression = LiteralExpression
    | AbsExpression
    | ParameterRef
    | LoopVariableRef
    | SumExpression
    | MethodCallExpression
    | IfExpression
    | BinaryExpression
    | GroupedExpression
    ;

LiteralExpression = StringLiteralExpression
    | NumberLiteralExpression
    | BooleanLiteralExpression ;

StringLiteralExpression = '"' stringLiteral '"';

NumberLiteralExpression = numberLiteral ;

BooleanLiteralExpression = booleanLiteral ;

AbsExpression = 'abs(' ExExpression ')' ;

ParameterRef = ParameterPiElemRef '.' AppliedFeature ;

AppliedFeature = AttributeRef ;

AttributeRef = AttributePiElemRef ;

LoopVariableRef = LoopVariablePiElemRef ;

SumExpression = 'sum' 'from' LoopVariable '=' ExExpression 'to' ExExpression 'of' ExExpression;

LoopVariable = identifier;

MethodCallExpression = 'CALL' MethodPiElemRef '(' [ExExpression / ',']* ')' ;

IfExpression = 'if' ExExpression 'then'
ExExpression
'else'
ExExpression
'endif';

BinaryExpression = [ExExpression / operator]2+ ;

leaf operator = '*' | '/' | '+' | 'and' | 'or' | '<' | '>' | '==' ;

GroupedExpression = '(' ExExpression ')' ;

EntityPiElemRef = identifier;

TypePiElemRef = identifier;

AttributePiElemRef = identifier;

ParameterPiElemRef = identifier;

LoopVariablePiElemRef = identifier;

MethodPiElemRef = identifier;

leaf identifier          = "[a-zA-Z_][a-zA-Z0-9_]*" ;
leaf numberLiteral       = "[0-9]+";
leaf booleanLiteral      = 'false' | 'true';

/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = "[^\\"]*";

    skip WHITE_SPACE = "\\s+" ;
    skip SINGLE_LINE_COMMENT = "//[^\r\n]*" ;

}
`;
// leaf stringLiteral       = "[^\"\\]*(\\.[^\"\\]*)*";
// skip MULTI_LINE_COMMENT = "/*[^*]**+(?:[^*/][^*]**+)*/" ;

