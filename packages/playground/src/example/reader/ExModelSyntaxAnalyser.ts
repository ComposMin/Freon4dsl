// Generated by the ProjectIt Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SyntaxAnalyser = net.akehurst.language.api.syntaxAnalyser.SyntaxAnalyser;
import SharedPackedParseTree = net.akehurst.language.api.sppt.SharedPackedParseTree;
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import SPPTLeaf = net.akehurst.language.api.sppt.SPPTLeaf;
import SPPTNode = net.akehurst.language.api.sppt.SPPTNode;
import {
    PiElementReference,
    ExModel,
    Entity,
    Method,
    Attribute,
    Type,
    Parameter,
    ExExpression,
    StringLiteralExpression,
    AttributeRef,
    NumberLiteralExpression,
    BooleanLiteralExpression,
    AbsExpression,
    ParameterRef,
    AppliedFeature,
    GroupedExpression,
    LoopVariableRef,
    LoopVariable,
    SumExpression,
    MethodCallExpression,
    IfExpression,
    LiteralExpression,
    MultiplyExpression,
    PlusExpression,
    DivideExpression,
    AndExpression,
    OrExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression
} from "../language/gen";
import { PiNamedElement } from "@projectit/core";

/**
 *   Class ExModelSyntaxAnalyser is ... TODO
 *
 */
export class ExModelSyntaxAnalyser implements SyntaxAnalyser {
    locationMap: any;

    clear(): void {
        throw new Error("Method not implemented.");
    }

    transform<T>(sppt: SharedPackedParseTree): T {
        if (!!sppt.root) {
            return (this.transformNode(sppt.root) as unknown) as T;
        } else {
            return null;
        }
    }

    private transformNode(node: SPPTNode): any {
        try {
            if (node.isLeaf) {
                return this.transformLeaf(node);
            } else if (node.isBranch) {
                return this.transformBranch(node as SPPTBranch);
            }
        } catch (e) {
            if (e.message.startsWith("Syntax error in ") || e.message.startsWith("Error in ExModelSyntaxAnalyser")) {
                throw e;
            } else {
                // add more info to the error message
                throw new Error(`Syntax error in "${node.matchedText}": ${e.message}`);
            }
        }
    }

    private transformLeaf(node: SPPTNode): any {
        let tmp = (node as SPPTLeaf).matchedText;
        if (tmp.startsWith('"')) {
            // stringLiteral
            // it is a stringLiteral, we should strip the surrounding quotes
            tmp = tmp.slice(1, tmp.length - 1);
            return tmp;
            // } else if (tmp == "true") { // booleanLiteral
            //     return true;
            // } else if (tmp == "false") { // booleanLiteral
            //     return false;
        } else if (Number.isInteger(parseInt(tmp))) {
            // numberLiteral
            return parseInt(tmp);
        } else {
            // identifier
            return tmp;
        }
    }

    private transformBranch(branch: SPPTBranch): any {
        let brName: string = branch.name;
        if ("ExModel" == brName) {
            return this.transformExModel(branch);
        } else if ("_OptionalbaseEntity" == brName) {
            return this.transform_OptionalbaseEntity(branch);
        } else if ("Entity" == brName) {
            return this.transformEntity(branch);
        } else if ("Attribute" == brName) {
            return this.transformAttribute(branch);
        } else if ("Method" == brName) {
            return this.transformMethod(branch);
        } else if ("StringLiteralExpression" == brName) {
            return this.transformStringLiteralExpression(branch);
        } else if ("AttributeRef" == brName) {
            return this.transformAttributeRef(branch);
        } else if ("NumberLiteralExpression" == brName) {
            return this.transformNumberLiteralExpression(branch);
        } else if ("BooleanLiteralExpression" == brName) {
            return this.transformBooleanLiteralExpression(branch);
        } else if ("AbsExpression" == brName) {
            return this.transformAbsExpression(branch);
        } else if ("ParameterRef" == brName) {
            return this.transformParameterRef(branch);
        } else if ("GroupedExpression" == brName) {
            return this.transformGroupedExpression(branch);
        } else if ("LoopVariableRef" == brName) {
            return this.transformLoopVariableRef(branch);
        } else if ("SumExpression" == brName) {
            return this.transformSumExpression(branch);
        } else if ("LoopVariable" == brName) {
            return this.transformLoopVariable(branch);
        } else if ("MethodCallExpression" == brName) {
            return this.transformMethodCallExpression(branch);
        } else if ("IfExpression" == brName) {
            return this.transformIfExpression(branch);
        } else if ("Parameter" == brName) {
            return this.transformParameter(branch);
        } else if ("ExExpression" == brName) {
            return this.transformExExpression(branch);
        } else if ("LiteralExpression" == brName) {
            return this.transformLiteralExpression(branch);
        } else if ("AppliedFeature" == brName) {
            return this.transformAppliedFeature(branch);
        } else if ("__pi_binary_expression" == brName) {
            return this.transform__pi_binary_expression(branch);
        } else {
            throw new Error(`Error in ExModelSyntaxAnalyser: ${brName} not handled`);
        }
    }

    /**
     * Method to transform branches that match the following rule:
     * ExModel = 'model' identifier '{'
     *	Entity*
     *	'model' 'wide' 'Methods:'
     *	Method*
     *	'}'
     * @param branch
     * @private
     */
    private transformExModel(branch: SPPTBranch): ExModel {
        // console.log("transformExModel called");
        const children = branch.nonSkipChildren.toArray();
        const name: string = this.transformNode(children[1]);
        const entities: Entity[] = this.transformList<Entity>(children[3]);
        const methods: Method[] = this.transformList<Method>(children[7]);
        return ExModel.create({ name: name, entities: entities, methods: methods });
    }

    /**
     * Method to transform branches that match the following rule:
     * _OptionalbaseEntity = 'base' EntityPiElemRef
     * @param branch
     * @private
     */
    private transform_OptionalbaseEntity(branch: SPPTBranch): PiElementReference<Entity> {
        console.log("transform_OptionalbaseEntity called");
        // An optional branch is a List with 0 or 1 element, so you always have the list node in between.
        return this.transformNode(branch.nonSkipChildren.toArray()[1]);
    }

    /**
     * Method to transform branches that match the following rule:
     * Entity = 'Entity' identifier _OptionalbaseEntity? '{'
     *	Attribute*
     *	Method*
     *	'}'
     * @param branch
     * @private
     */
    private transformEntity(branch: SPPTBranch): Entity {
        // console.log("transformEntity called");
        const children = branch.nonSkipChildren.toArray();
        const name: string = this.transformNode(children[1]);
        const baseEntityNode = children[2] as SPPTBranch;
        let baseEntity = null;
        if (!baseEntityNode.isEmptyMatch) {
            // take the first element in the [0..1] optional group
            // and the 1(-st/nd/rd/th) element of that group
            // hack: group has two occurences, therefore twice 'nonSkipChildren.toArray()[0]'
            let propNode = baseEntityNode.nonSkipChildren.toArray()[0].nonSkipChildren.toArray()[0].nonSkipChildren.toArray()[1];
            baseEntity = this.piElemRef<Entity>(propNode, "Entity");
        }
        const attributes: Attribute[] = this.transformList<Attribute>(children[4]);
        const methods: Method[] = this.transformList<Method>(children[5]);
        return Entity.create({ name: name, baseEntity: baseEntity, attributes: attributes, methods: methods });
    }

    /**
     * Method to transform branches that match the following rule:
     * Attribute = identifier ':' TypePiElemRef
     * @param branch
     * @private
     */
    private transformAttribute(branch: SPPTBranch): Attribute {
        // console.log("transformAttribute called");
        const children = branch.nonSkipChildren.toArray();
        const name: string = this.transformNode(children[0]);
        const declaredType: PiElementReference<Type> = this.piElemRef<Type>(children[2], "Type");
        return Attribute.create({ name: name, declaredType: declaredType });
    }

    /**
     * Method to transform branches that match the following rule:
     * Method = 'method' identifier '(' [Parameter / ',' ]* '):' TypePiElemRef '{'
     *	ExExpression
     *	'}'
     * @param branch
     * @private
     */
    private transformMethod(branch: SPPTBranch): Method {
        // console.log("transformMethod called");
        const children = branch.nonSkipChildren.toArray();
        const name: string = this.transformNode(children[1]);
        const parameters: Parameter[] = this.transformList<Parameter>(children[3], ",");
        const declaredType: PiElementReference<Type> = this.piElemRef<Type>(children[5], "Type");
        const body: ExExpression = this.transformNode(children[7]);
        return Method.create({ name: name, parameters: parameters, declaredType: declaredType, body: body });
    }

    /**
     * Method to transform branches that match the following rule:
     * StringLiteralExpression = '\\'' stringLiteral '\\''
     * @param branch
     * @private
     */
    private transformStringLiteralExpression(branch: SPPTBranch): StringLiteralExpression {
        // console.log("transformStringLiteralExpression called");
        const children = branch.nonSkipChildren.toArray();
        const value: string = this.transformNode(children[1]);
        return StringLiteralExpression.create({ value: value });
    }

    /**
     * Method to transform branches that match the following rule:
     * AttributeRef = AttributePiElemRef
     * @param branch
     * @private
     */
    private transformAttributeRef(branch: SPPTBranch): AttributeRef {
        // console.log("transformAttributeRef called");
        const children = branch.nonSkipChildren.toArray();
        const attribute: PiElementReference<Attribute> = this.piElemRef<Attribute>(children[0], "Attribute");
        return AttributeRef.create({ attribute: attribute });
    }

    /**
     * Method to transform branches that match the following rule:
     * NumberLiteralExpression = numberLiteral
     * @param branch
     * @private
     */
    private transformNumberLiteralExpression(branch: SPPTBranch): NumberLiteralExpression {
        // console.log("transformNumberLiteralExpression called");
        const children = branch.nonSkipChildren.toArray();
        const value: number = this.transformNode(children[0]);
        return NumberLiteralExpression.create({ value: value });
    }

    /**
     * Method to transform branches that match the following rule:
     * BooleanLiteralExpression = booleanLiteral
     * @param branch
     * @private
     */
    private transformBooleanLiteralExpression(branch: SPPTBranch): BooleanLiteralExpression {
        // console.log("transformBooleanLiteralExpression called");
        const children = branch.nonSkipChildren.toArray();
        const value: boolean = this.transformNode(children[0]);
        return BooleanLiteralExpression.create({ value: value });
    }

    /**
     * Method to transform branches that match the following rule:
     * AbsExpression = '|' ExExpression '|'
     * @param branch
     * @private
     */
    private transformAbsExpression(branch: SPPTBranch): AbsExpression {
        // console.log("transformAbsExpression called");
        const children = branch.nonSkipChildren.toArray();
        const expr: ExExpression = this.transformNode(children[1]);
        return AbsExpression.create({ expr: expr });
    }

    /**
     * Method to transform branches that match the following rule:
     * ParameterRef = ParameterPiElemRef '.' AppliedFeature
     * @param branch
     * @private
     */
    private transformParameterRef(branch: SPPTBranch): ParameterRef {
        // console.log("transformParameterRef called");
        const children = branch.nonSkipChildren.toArray();
        const parameter: PiElementReference<Parameter> = this.piElemRef<Parameter>(children[0], "Parameter");
        const appliedfeatureNode = children[2] as SPPTBranch;
        let appliedfeature = null;
        if (!appliedfeatureNode.isEmptyMatch) {
            // transform the first element in the [0..1] optional collection
            appliedfeature = this.transformNode(appliedfeatureNode.nonSkipChildren.toArray()[0]);
        }
        return ParameterRef.create({ parameter: parameter, appliedfeature: appliedfeature });
    }

    /**
     * Method to transform branches that match the following rule:
     * GroupedExpression = '(' ExExpression ')'
     * @param branch
     * @private
     */
    private transformGroupedExpression(branch: SPPTBranch): GroupedExpression {
        // console.log("transformGroupedExpression called");
        const children = branch.nonSkipChildren.toArray();
        const inner: ExExpression = this.transformNode(children[1]);
        return GroupedExpression.create({ inner: inner });
    }

    /**
     * Method to transform branches that match the following rule:
     * LoopVariableRef = LoopVariablePiElemRef
     * @param branch
     * @private
     */
    private transformLoopVariableRef(branch: SPPTBranch): LoopVariableRef {
        // console.log("transformLoopVariableRef called");
        const children = branch.nonSkipChildren.toArray();
        const variable: PiElementReference<LoopVariable> = this.piElemRef<LoopVariable>(children[0], "LoopVariable");
        return LoopVariableRef.create({ variable: variable });
    }

    /**
     * Method to transform branches that match the following rule:
     * SumExpression = 'sum' 'from' LoopVariable '=' ExExpression 'to' ExExpression 'of' ExExpression
     * @param branch
     * @private
     */
    private transformSumExpression(branch: SPPTBranch): SumExpression {
        // console.log("transformSumExpression called");
        const children = branch.nonSkipChildren.toArray();
        const variable: LoopVariable = this.transformNode(children[2]);
        const from: ExExpression = this.transformNode(children[4]);
        const to: ExExpression = this.transformNode(children[6]);
        const body: ExExpression = this.transformNode(children[8]);
        return SumExpression.create({ variable: variable, from: from, to: to, body: body });
    }

    /**
     * Method to transform branches that match the following rule:
     * LoopVariable = identifier
     * @param branch
     * @private
     */
    private transformLoopVariable(branch: SPPTBranch): LoopVariable {
        // console.log("transformLoopVariable called");
        const children = branch.nonSkipChildren.toArray();
        const name: string = this.transformNode(children[0]);
        return LoopVariable.create({ name: name });
    }

    /**
     * Method to transform branches that match the following rule:
     * MethodCallExpression = 'CALL' MethodPiElemRef '(' [ExExpression / ',' ]* ')'
     * @param branch
     * @private
     */
    private transformMethodCallExpression(branch: SPPTBranch): MethodCallExpression {
        // console.log("transformMethodCallExpression called");
        const children = branch.nonSkipChildren.toArray();
        const methodDefinition: PiElementReference<Method> = this.piElemRef<Method>(children[1], "Method");
        const args: ExExpression[] = this.transformList<ExExpression>(children[3], ",");
        return MethodCallExpression.create({ methodDefinition: methodDefinition, args: args });
    }

    /**
     * Method to transform branches that match the following rule:
     * IfExpression = 'if' '(' ExExpression ')' 'then'
     *	ExExpression
     *	'else'
     *	ExExpression
     *	'endif'
     * @param branch
     * @private
     */
    private transformIfExpression(branch: SPPTBranch): IfExpression {
        // console.log("transformIfExpression called");
        const children = branch.nonSkipChildren.toArray();
        const condition: ExExpression = this.transformNode(children[2]);
        const whenTrue: ExExpression = this.transformNode(children[5]);
        const whenFalse: ExExpression = this.transformNode(children[7]);
        return IfExpression.create({ condition: condition, whenTrue: whenTrue, whenFalse: whenFalse });
    }

    /**
     * Method to transform branches that match the following rule:
     * Parameter = identifier ':' TypePiElemRef
     * @param branch
     * @private
     */
    private transformParameter(branch: SPPTBranch): Parameter {
        // console.log("transformParameter called");
        const children = branch.nonSkipChildren.toArray();
        const name: string = this.transformNode(children[0]);
        const declaredType: PiElementReference<Type> = this.piElemRef<Type>(children[2], "Type");
        return Parameter.create({ name: name, declaredType: declaredType });
    }

    /**
     * Method to transform branches that match the following rule:
     * ExExpression = LiteralExpression
     *    | AbsExpression
     *    | ParameterRef
     *    | GroupedExpression
     *    | LoopVariableRef
     *    | SumExpression
     *    | MethodCallExpression
     *    | IfExpression
     *    | __pi_binary_expression
     * @param branch
     * @private
     */
    private transformExExpression(branch: SPPTBranch): ExExpression {
        // console.log("transformExExpression called");
        return this.transformNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * LiteralExpression = StringLiteralExpression
     *    | NumberLiteralExpression
     *    | BooleanLiteralExpression
     * @param branch
     * @private
     */
    private transformLiteralExpression(branch: SPPTBranch): LiteralExpression {
        // console.log("transformLiteralExpression called");
        return this.transformNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * AppliedFeature = AttributeRef
     * @param branch
     * @private
     */
    private transformAppliedFeature(branch: SPPTBranch): AppliedFeature {
        // console.log("transformAppliedFeature called");
        return this.transformNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Generic method to transform binary expressions.
     * Binary expressions are parsed according to these rules:
     * __pi_binary_expression = [ExExpression / __pi_binary_operator]2+
     * leaf __pi_binary_operator = '*' | '+' | '/' | 'and' | 'or' | '<' | '>' | '=='
     *
     * In this method we build a crooked tree, which in a later phase needs to be balanced
     * according to the priorities of the operators.
     * @param branch
     * @private
     */
    private transform__pi_binary_expression(branch: SPPTBranch): ExExpression {
        // console.log("transform__pi_binary_expression called");
        const children = branch.nonSkipChildren.toArray();
        const actualList = children[0].nonSkipChildren.toArray();
        let index = 0;
        let first = this.transformNode(actualList[index++]);
        while (index < actualList.length) {
            let operator = this.transformNode(actualList[index++]);
            let second = this.transformNode(actualList[index++]);
            let combined: ExExpression = null;
            switch (operator) {
                case "*": {
                    combined = MultiplyExpression.create({ left: first, right: second });
                    break;
                }
                case "+": {
                    combined = PlusExpression.create({ left: first, right: second });
                    break;
                }
                case "/": {
                    combined = DivideExpression.create({ left: first, right: second });
                    break;
                }
                case "and": {
                    combined = AndExpression.create({ left: first, right: second });
                    break;
                }
                case "or": {
                    combined = OrExpression.create({ left: first, right: second });
                    break;
                }
                case "<": {
                    combined = LessThenExpression.create({ left: first, right: second });
                    break;
                }
                case ">": {
                    combined = GreaterThenExpression.create({ left: first, right: second });
                    break;
                }
                case "==": {
                    combined = EqualsExpression.create({ left: first, right: second });
                    break;
                }
                default: {
                    combined = null;
                }
            }
            first = combined;
        }
        return first;
    }

    /**
     * Generic method to transform references
     * ...PiElemRef = identifier;
     */
    private piElemRef<T extends PiNamedElement>(branch: SPPTBranch, typeName: string): PiElementReference<T> {
        let refName: string = this.transformNode(branch.nonSkipChildren.toArray()[0]);
        // if (!refName || refName.length == 0) throw new Error(`Syntax error in "${branch.matchedText}": cannot create empty reference`);
        return PiElementReference.create<T>(refName, typeName);
    }

    /**
     * Generic method to transform lists
     */
    private transformList<T>(branch: SPPTBranch, separator?: string): T[] {
        let result: T[] = [];
        for (const child of branch.nonSkipChildren.toArray()) {
            let element: any = this.transformNode(child);
            if (element) {
                if (!separator) {
                    result.push(element);
                } else {
                    if (element !== separator) result.push(element);
                }
            }
        }
        return result;
    }
}
