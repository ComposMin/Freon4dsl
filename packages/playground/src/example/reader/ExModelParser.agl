// This file contains the input to the AGL parser.

ExModel = "model" variable "{"
	(Entity)*
	"model" "wide" "Methods:"
	MethodList2
	"}" ;

Entity = "Entity" variable ("base" EntityPiElemRef )? "{"
    	AttributeList3
    	MethodList4
    	"}" ;

Attribute = variable ":" TypePiElemRef; 

Method = "method" variable "(" ParameterList5 "):" TypePiElemRef "{" 
	ExExpression 
	"}" ;

ExExpression = LiteralExpression 
    | AbsExpression 
    | ParameterRef 
    | LoopVariableRef 
    | SumExpression 
    | MethodCallExpression 
    | IfExpression 
    | BinaryExpression ;

LiteralExpression = StringLiteralExpression 
    | NumberLiteralExpression 
    | BooleanLiteralExpression ;

StringLiteralExpression = "'" stringLiteral "'" ;

AppliedFeature = AttributeRef ;

AttributeRef = AttributePiElemRef ;

NumberLiteralExpression = stringLiteral ;

BooleanLiteralExpression = stringLiteral ;

AbsExpression = "abs(" ExExpression ")" ;

ParameterRef = ParameterPiElemRef "." AppliedFeature ;

LoopVariableRef = LoopVariablePiElemRef ;

SumExpression = "sum" "from" LoopVariable "=" ExExpression "to" ExExpression "of" ExExpression;

LoopVariable = variable;

MethodCallExpression = "CALL" MethodPiElemRef "(" ExExpressionList6 ")" ;

IfExpression = "if" "(" ExExpression ")" "then" 
	ExExpression
	"else" 
	ExExpression
	"endif";

BinaryExpression = MultiplyExpression
    | PlusExpression
    | DivideExpression
    | AndExpression
    | OrExpression 
    | ComparisonExpression;

MultiplyExpression = "(" ExExpression "*" ExExpression ")";
    
PlusExpression = "(" ExExpression "+" ExExpression ")";
    
DivideExpression = "(" ExExpression "|" ExExpression ")";
    
AndExpression = "(" ExExpression "and" ExExpression ")";
    
OrExpression = "(" ExExpression "or" ExExpression ")";
    
ComparisonExpression = LessThenExpression 
    | GreaterThenExpression
    | EqualsExpression;

LessThenExpression = "(" ExExpression "<" ExExpression ")";
    
GreaterThenExpression = "(" ExExpression ">" ExExpression ")";

EqualsExpression = "(" ExExpression "==" ExExpression ")";
    
Parameter = variable  ":"  TypePiElemRef;

EntityPiElemRef = variable;

TypePiElemRef = variable;

AttributePiElemRef = variable;

ParameterPiElemRef = variable;

LoopVariablePiElemRef = variable;

MethodPiElemRef = variable;

MethodList2 = Method*;

AttributeList3 = Attribute*;

MethodList4 = Method*;

ParameterList5 = [Parameter / ',']*; // comma-separated list

ExExpressionList6 = [ExExpression / ',']*; // comma-separated list

varLetter           = "[a-zA-Z]";
identifierChar      = "[a-zA-Z0-9_$]"; // any char but not /.,!?@~%^&*-=+(){}"':;<>?[]"/
anyChar             = "[a-zA-Z0-9' /\-\[\]\"+<>=#$_.,!?@~%^&\*-=+(){}:;<>?]";
number              = "[0-9]";

leaf variable            = varLetter identifierChar*;
leaf stringLiteral       = """ anyChar* """;
leaf numberLiteral       = number+;
leaf booleanLiteral      = "false"
                    | "true";

// TODO see whether the stuff under LINE can be replaced by
            skip WHITE_SPACE = "\s+" ;
	        skip MULTI_LINE_COMMENT = "/\*[^*]*\*+(?:[^*/][^*]*\*+)*/" ;
	        skip SINGLE_LINE_COMMENT = "//.*?${'$'}" ;
// LINE LINE
"whitespace" = (([ \t\n\r]") | (SingleLineComment) | (MultiLineComment) )*
r"required whitespace" = (([ \t\n\r]") | (SingleLineComment) | (MultiLineComment) )+

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)*

LineTerminator
  = "[\n\r\u2028\u2029]"


Comment "comment"
  = MultiLineComment
  | SingleLineComment

// TODO Jos: why this rule?
MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

leaf SourceCharacter
  = ".";
  
char
  = unescaped
  | escape
    sequence:(
        '"'
      | "\\"
      | "/"
      | "\["
      | "\]"
      | "$"
      | "b"
      | "f"
      | "n"
      | "r"
      | "t"
      | "u" (HEXDIG HEXDIG HEXDIG HEXDIG)
    );

leaf escape
  = "\\";

leaf unescaped
  = "[^\0-\x1F\x22\x5C]";

// ----- Core ABNF Rules -----

// See RFC 4234, Appendix B (http://tools.ietf.org/html/rfc4234).
leaf DIGIT  = "[0-9]";
leaf HEXDIG = "[0-9a-f]";
