// Generated by the ProjectIt Language Generator.
import { PiElement, PiTyperPart } from "@projectit/core";
import {
    GenericKind,
    GenericLiteral,
    GenericType,
    NamedType, PiElementReference, PredefinedType,
    ProjectXEveryConcept, Type, TypeRef, TypeUsage,
    UnitOfMeasurement
} from "../language/gen";
import { ProjectXTyper } from "./gen";
import { ProjectXEnvironment } from "../environment/gen/ProjectXEnvironment";
import { ListUtil } from "./ListUtil";
import { CommonSuperTypeUtil } from "./common-super/CommonSuperTypeUtil";

/**
 * Class 'CustomProjectXTyperPart' is meant to be a convient place to add any
 * custom code for type checking.
 */
export class CustomProjectXTyperPart implements PiTyperPart {
    mainTyper: ProjectXTyper;

    /**
     * See interface
     */
    public inferType(modelelement: ProjectXEveryConcept): ProjectXEveryConcept | null {
        // THIS IS CORRECT CODE, BUT NOT YET GENERATED => KEEP!!!

        // const writer = ProjectXEnvironment.getInstance().writer;
        // if (modelelement.piLanguageConcept() === "GenericLiteral") {
        //     let inner: Type;
        //     if ((modelelement as GenericLiteral).content.length === 0) {
        //         inner = this.mainTyper.anytype;
        //     } else {
        //         inner = this.mainTyper.inferType(this.mainTyper.commonSuperType((modelelement as GenericLiteral).content));
        //     }
        //     let baseType: TypeUsage;
        //     if (inner instanceof NamedType) {
        //         // have to wrap it
        //         baseType = TypeRef.create({
        //             type: PiElementReference.create<NamedType>(inner as NamedType, "NamedType")
        //         });
        //     } else if (inner instanceof TypeUsage) {
        //         // no need to wrap
        //         baseType = inner;
        //     }
        //     const result = GenericType.create({
        //         baseType: baseType,
        //         kind: PiElementReference.create<GenericKind>((modelelement as GenericLiteral).kind.referred as GenericKind, "GenericKind")
        //     });
        //     console.log("GEN_TYPER.inferType of " + writer.writeToString(modelelement) + " => " + writer.writeToString(result) + ", " + result.piId());
        //     return result;
        // } else {
            return null;
        // }
    }
    /**
     * See interface
     */
    public equalsType(elem1: ProjectXEveryConcept, elem2: ProjectXEveryConcept): boolean | null {
        const writer = ProjectXEnvironment.getInstance().writer;
        const type1: ProjectXEveryConcept = this.mainTyper.inferType(elem1);
        const type2: ProjectXEveryConcept = this.mainTyper.inferType(elem2);

        let result: boolean = false;
        if (type1 === null || type1 === undefined) {
            // console.log("found null type for "+ writer.writeToString(elem1) + ', ' + elem1.piLanguageConcept());
            result = false;
        } else if (type2 === null || type2 === undefined) {
            // console.log("found null type for "+ writer.writeToString(elem2) + ', ' + elem2.piLanguageConcept());
            result = false;
        } else if (type1.piLanguageConcept() !== type2.piLanguageConcept()) {
            // console.log("language concepts wrong: " + type1.piLanguageConcept() + ", " + type2.piLanguageConcept())
            result = false;
        } else if (type1.piLanguageConcept() === "PredefinedType"){
            // console.log("PredefinedType")
            result = type1 === type2;
        } else if (type1.piLanguageConcept() === "NamedType"){
            // equalsto aa:NamedType where {
            //     aa.name equalsto self.name;
            // };
            // console.log("NamedType")
        } else if (type1.piLanguageConcept() === "TypeRef"){
            // console.log("TypeRef")
            result = this.mainTyper.equalsType((type1 as TypeRef).type.referred,  (type2 as TypeRef).type.referred);
        } else if (type1.piLanguageConcept() === "GenericType"){
            // equalsto x:GenericType where {
            //     x.innerType equalsto self.innerType;
            //     x.kind equalsto self.kind;
            // };
            const condition1: boolean = this.mainTyper.equalsType((type1 as GenericType).baseType, (type2 as GenericType).baseType);
            const condition2: boolean = (type1 as GenericType).kind.referred === (type2 as GenericType).kind.referred;
            // console.log("GenericType: " + writer.writeToString(elem1) + condition1 + ", " + condition2);
            result = condition1 && condition2;
        } else if (type1.piLanguageConcept() === "UnitOfMeasurement"){
            // equalsto aap:UnitOfMeasurement where {
            //     aap.baseType equalsto self.baseType;
            //     aap.unit equalsto self.unit;
            // };
            const condition1: boolean = this.mainTyper.equalsType((type1 as UnitOfMeasurement).baseType.referred, (type2 as UnitOfMeasurement).baseType.referred);
            const condition2: boolean = (type1 as UnitOfMeasurement).unit.referred === (type2 as UnitOfMeasurement).unit.referred;
            // console.log("UnitOfMeasurement " + writer.writeToString(elem1) + condition1 + ", " + condition2);
            result = condition1 && condition2;
        }
        // console.log("CUSTOM.equalsType: " + writer.writeNameOnly(elem1) + ", " + writer.writeNameOnly(elem2)
        //     + "\n\t types are: " + writer.writeNameOnly(type1) + ", " + writer.writeNameOnly(type2)
        //     + "\n\t ids of types are: " + type1?.piId() + ", " + type2?.piId()
        //     + "\n\t result: " + result);
        return result;
    }
    /**
     * See interface
     */
    public conformsTo(elem1: ProjectXEveryConcept, elem2: ProjectXEveryConcept): boolean | null {
        return null;
    }
    /**
     * See interface
     */
    public conformList(typelist1: ProjectXEveryConcept[], typelist2: ProjectXEveryConcept[]): boolean | null {
        return null;
    }
    /**
     * See interface
     */
    public isType(elem: ProjectXEveryConcept): boolean | null {
        return null;
    }

    public commonSuperType(inlist: ProjectXEveryConcept[]): Type | null {
        const writer = ProjectXEnvironment.getInstance().writer;

        // check if we have real types in the typelist
        const typelist: Type[] = [];
        for (const elem of inlist) {
            ListUtil.addIfNotPresent(typelist, this.mainTyper.inferType(elem));
        }
        // console.log("commonSuperType: " + typelist.map(type => writer.writeNameOnly(type)).join(", ") );
        const result = CommonSuperTypeUtil.commonSuperType(typelist);
        // console.log("\tresult: " + result.map(type => writer.writeNameOnly(type)).join(", ") );

        if (!!result && result.length > 0) {
            return result[0];
        } else {
            return null;
        }
    }

    getSupers(elem: PiElement): PiElement[] {
        if (elem === PredefinedType.NUMBER || elem === PredefinedType.BOOLEAN)
        { return [PredefinedType.STRING]}
        return [];
    }
}
