typer

// What are types?
istype { TypeUsage }

//type AAP {
//    noot: Mies;
//    piet: Kleppe;
//}
// Which concepts have a type?
hastype { Exp, NamedType }

// What are the top and bottom types?
//anytype {
//    conformsto x:TypeRef where {
//        x.type equalsto PredefinedType:ANY; // PredefinedType:ANY is the least specific type
//    } ;
//}

//PredefinedType {
//    PredefinedType:NULL conformsto anytype; // PredefinedType:NULL is the most specific type
//}

// Which type does an expression have?
NumberLiteral {
    infertype TypeRef {
        type: PredefinedType:NUMBER
    } ;
}

StringLiteral {
    infertype TypeRef {
        type: PredefinedType:STRING
    } ;
}

BooleanLiteral {
    infertype TypeRef {
        type: PredefinedType:BOOLEAN
    } ;
}

NamedType {
    infertype TypeRef {
        type: self
    } ;
}

NamedExp {
    infertype TypeRef {
        type: self.myType
    } ;
}

PlusExp {
    infertype commonSuperType(self.left, self.right);
}

UnitLiteral {
    // 62 kilogram, or 112 miles
    infertype UnitOfMeasurement {
        baseType: typeof(self.inner).type,
        unit: self.unit
    };
//    infertype x:TypeRef where {
//        x.type equalsto PredefinedType:BOOLEAN;
//    } ;

}

GenericLiteral {
    // Set{ 12, 14, 16, 18 }
    infertype GenericType {
        // TODO the following results in a compile error, but not in a checker error
        // x.baseType equalsto (typeof(self.content) as Type);
        baseType: typeof(self.content),
        kind: self.kind
    };
}

// Which types are 'equal' to each other?
//NamedType {
//    equalsto aa:NamedType where {
//            aa.name equalsto self.name;
//        };
//}

TypeRef {
    equalsto tt:TypeRef where {
        tt.type equalsto self.type;
    } ;
    conformsto tt:TypeRef where {
        tt.type conformsto self.type;
    } ;
}

GenericType {
    equalsto x:GenericType where {
            x.baseType equalsto self.baseType;
            x.kind equalsto self.kind;
        };
    conformsto x:GenericType where {
            // both conditions must be true
            self.baseType conformsto x.baseType;
            self.kind conformsto x.kind;
        };
}

GenericKind {
    Set conformsto Collection;
    Sequence conformsto Bag;
    Bag conformsto Collection;
}

UnitOfMeasurement {
    equalsto aap:UnitOfMeasurement where {
            aap.baseType equalsto self.baseType;
            aap.unit equalsto self.unit;
        };
    conformsto rr:UnitOfMeasurement where {
            self.baseType conformsto rr.baseType;
            self.unit equalsto rr.unit;
            // self.unit equalsto rr.unit; TODO this should result in an error message
        };
}

PredefinedType {
    NUMBER conformsto STRING;
    BOOLEAN conformsto STRING;
}
