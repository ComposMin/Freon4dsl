// Generated by the ProjectIt Language Generator (4/1/2020, 2:08:57 PM).
import { AllTaxRulesConcepts } from "../../language/gen/";
import {
    RevenueService,
    TaxRuleSet,
    TaxPayer,
    IncomePart,
    Money,
    TaxID,
    TaxRule,
    RuleParameter,
    PercentageExpression,
    MoneyLiteralExp,
    TaxRuleCall,
    Expression,
    PlaceholderExpression,
    LiteralExpression,
    StringLiteralExpression,
    NumberLiteralExpression,
    BooleanLiteralExpression,
    AbsExpression,
    BinaryExpression,
    MultiplyExpression,
    PlusExpression,
    DivideExpression,
    AndExpression,
    OrExpression,
    ComparisonExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression,
    IfExpression
} from "../../language/gen/";
import { IncomeType, TaxPayerType } from "../../language/gen/";

// TODO change import to @project/core
import { PiLogger } from "../../../../../core/src/util/PiLogging";
import { TaxRulesWorker } from "./TaxRulesWorker";

const LOGGER = new PiLogger("TaxRulesWalker");

export class TaxRulesWalker {
    myWorker: TaxRulesWorker;

    public walk(modelelement: AllTaxRulesConcepts, includeChildren?: boolean) {
        if (modelelement instanceof IfExpression) {
            return this.walkIfExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof EqualsExpression) {
            return this.walkEqualsExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof GreaterThenExpression) {
            return this.walkGreaterThenExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof LessThenExpression) {
            return this.walkLessThenExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof ComparisonExpression) {
            return this.walkComparisonExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof OrExpression) {
            return this.walkOrExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof AndExpression) {
            return this.walkAndExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof DivideExpression) {
            return this.walkDivideExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof PlusExpression) {
            return this.walkPlusExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof MultiplyExpression) {
            return this.walkMultiplyExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof BinaryExpression) {
            return this.walkBinaryExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof AbsExpression) {
            return this.walkAbsExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof BooleanLiteralExpression) {
            return this.walkBooleanLiteralExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof NumberLiteralExpression) {
            return this.walkNumberLiteralExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof StringLiteralExpression) {
            return this.walkStringLiteralExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof LiteralExpression) {
            return this.walkLiteralExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof MoneyLiteralExp) {
            return this.walkMoneyLiteralExp(modelelement, includeChildren);
        }
        if (modelelement instanceof PercentageExpression) {
            return this.walkPercentageExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof IfExpression) {
            return this.walkIfExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof EqualsExpression) {
            return this.walkEqualsExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof GreaterThenExpression) {
            return this.walkGreaterThenExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof LessThenExpression) {
            return this.walkLessThenExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof ComparisonExpression) {
            return this.walkComparisonExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof OrExpression) {
            return this.walkOrExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof AndExpression) {
            return this.walkAndExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof DivideExpression) {
            return this.walkDivideExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof PlusExpression) {
            return this.walkPlusExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof MultiplyExpression) {
            return this.walkMultiplyExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof BinaryExpression) {
            return this.walkBinaryExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof AbsExpression) {
            return this.walkAbsExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof BooleanLiteralExpression) {
            return this.walkBooleanLiteralExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof NumberLiteralExpression) {
            return this.walkNumberLiteralExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof StringLiteralExpression) {
            return this.walkStringLiteralExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof LiteralExpression) {
            return this.walkLiteralExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof PercentageExpression) {
            return this.walkPercentageExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof RevenueService) {
            return this.walkRevenueService(modelelement, includeChildren);
        }
        if (modelelement instanceof TaxRuleSet) {
            return this.walkTaxRuleSet(modelelement, includeChildren);
        }
        if (modelelement instanceof TaxPayer) {
            return this.walkTaxPayer(modelelement, includeChildren);
        }
        if (modelelement instanceof IncomePart) {
            return this.walkIncomePart(modelelement, includeChildren);
        }
        if (modelelement instanceof Money) {
            return this.walkMoney(modelelement, includeChildren);
        }
        if (modelelement instanceof TaxID) {
            return this.walkTaxID(modelelement, includeChildren);
        }
        if (modelelement instanceof TaxRule) {
            return this.walkTaxRule(modelelement, includeChildren);
        }
        if (modelelement instanceof RuleParameter) {
            return this.walkRuleParameter(modelelement, includeChildren);
        }
        if (modelelement instanceof TaxRuleCall) {
            return this.walkTaxRuleCall(modelelement, includeChildren);
        }
        if (modelelement instanceof Expression) {
            return this.walkExpression(modelelement, includeChildren);
        }
        if (modelelement instanceof PlaceholderExpression) {
            return this.walkPlaceholderExpression(modelelement, includeChildren);
        }
    }

    public walkRevenueService(modelelement: RevenueService, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeRevenueService(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkTaxRuleSet(modelelement.rules, includeChildren);
                modelelement.payers.forEach(p => {
                    this.walkTaxPayer(p, includeChildren);
                });
            }
            this.myWorker.execAfterRevenueService(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkTaxRuleSet(modelelement: TaxRuleSet, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeTaxRuleSet(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                modelelement.taxrules.forEach(p => {
                    this.walkTaxRule(p, includeChildren);
                });
            }
            this.myWorker.execAfterTaxRuleSet(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkTaxPayer(modelelement: TaxPayer, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeTaxPayer(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkTaxID(modelelement.taxId, includeChildren);
                modelelement.incomeParts.forEach(p => {
                    this.walkIncomePart(p, includeChildren);
                });
                this.walkMoney(modelelement.totalIncome, includeChildren);
                this.walkMoney(modelelement.totalTaxes, includeChildren);
            }
            this.myWorker.execAfterTaxPayer(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkIncomePart(modelelement: IncomePart, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeIncomePart(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkMoney(modelelement.deduction, includeChildren);
                this.walkMoney(modelelement.amount, includeChildren);
            }
            this.myWorker.execAfterIncomePart(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkMoney(modelelement: Money, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeMoney(modelelement);

            this.myWorker.execAfterMoney(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkTaxID(modelelement: TaxID, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeTaxID(modelelement);

            this.myWorker.execAfterTaxID(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkTaxRule(modelelement: TaxRule, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeTaxRule(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.expression, includeChildren);
            }
            this.myWorker.execAfterTaxRule(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkRuleParameter(modelelement: RuleParameter, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeRuleParameter(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkIncomePart(modelelement.type, includeChildren);
            }
            this.myWorker.execAfterRuleParameter(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkPercentageExpression(modelelement: PercentageExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforePercentageExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.inner, includeChildren);
            }
            this.myWorker.execAfterPercentageExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkMoneyLiteralExp(modelelement: MoneyLiteralExp, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeMoneyLiteralExp(modelelement);

            this.myWorker.execAfterMoneyLiteralExp(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkTaxRuleCall(modelelement: TaxRuleCall, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeTaxRuleCall(modelelement);

            this.myWorker.execAfterTaxRuleCall(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkExpression(modelelement: Expression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeExpression(modelelement);

            this.myWorker.execAfterExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkPlaceholderExpression(modelelement: PlaceholderExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforePlaceholderExpression(modelelement);

            this.myWorker.execAfterPlaceholderExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkLiteralExpression(modelelement: LiteralExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeLiteralExpression(modelelement);

            this.myWorker.execAfterLiteralExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkStringLiteralExpression(modelelement: StringLiteralExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeStringLiteralExpression(modelelement);

            this.myWorker.execAfterStringLiteralExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkNumberLiteralExpression(modelelement: NumberLiteralExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeNumberLiteralExpression(modelelement);

            this.myWorker.execAfterNumberLiteralExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkBooleanLiteralExpression(modelelement: BooleanLiteralExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeBooleanLiteralExpression(modelelement);

            this.myWorker.execAfterBooleanLiteralExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkAbsExpression(modelelement: AbsExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeAbsExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.expr, includeChildren);
            }
            this.myWorker.execAfterAbsExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkBinaryExpression(modelelement: BinaryExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeBinaryExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterBinaryExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkMultiplyExpression(modelelement: MultiplyExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeMultiplyExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterMultiplyExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkPlusExpression(modelelement: PlusExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforePlusExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterPlusExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkDivideExpression(modelelement: DivideExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeDivideExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterDivideExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkAndExpression(modelelement: AndExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeAndExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterAndExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkOrExpression(modelelement: OrExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeOrExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterOrExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkComparisonExpression(modelelement: ComparisonExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeComparisonExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterComparisonExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkLessThenExpression(modelelement: LessThenExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeLessThenExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterLessThenExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkGreaterThenExpression(modelelement: GreaterThenExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeGreaterThenExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterGreaterThenExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkEqualsExpression(modelelement: EqualsExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeEqualsExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.left, includeChildren);
                this.walkExpression(modelelement.right, includeChildren);
            }
            this.myWorker.execAfterEqualsExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkIfExpression(modelelement: IfExpression, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeIfExpression(modelelement);

            // work on children in the model tree
            if (!(includeChildren === undefined) && includeChildren) {
                this.walkExpression(modelelement.condition, includeChildren);
                this.walkExpression(modelelement.whenTrue, includeChildren);
                this.walkExpression(modelelement.whenFalse, includeChildren);
            }
            this.myWorker.execAfterIfExpression(modelelement);
        } else {
            LOGGER.error(this, "No worker found.");
            return;
        }
    }

    public walkIncomeType(modelelement: IncomeType, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeIncomeType(modelelement);
            this.myWorker.execAfterIncomeType(modelelement);
        }
    }

    public walkTaxPayerType(modelelement: TaxPayerType, includeChildren?: boolean) {
        if (!!this.myWorker) {
            this.myWorker.execBeforeTaxPayerType(modelelement);
            this.myWorker.execAfterTaxPayerType(modelelement);
        }
    }
}
