language PiLanguage

// begin typer definition
modelunit PiTyperDef {
    name: identifier = "TYPER";
    location?: PiParseLocation;
    reference types: PiClassifier[];
    reference conceptsWithType: PiClassifier[];
    anyTypeRule?: PitAnyTypeRule;
    classifierRules: PitClassifierRule[];
    reference typeroot?: PiClassifier;
    file-extension = "type";
}

limited PitStatementKind {
    EQUALS = {name: "equalsto"}
    CONFORMS = {name: "conformsto"}
}

concept PitAnyTypeRule {
    myRules: PitSingleRule[];
}

abstract concept PitClassifierRule {
    reference myClassifier: PiClassifier;
}
concept PitConformanceOrEqualsRule base PitClassifierRule {
    myRules: PitSingleRule[];
}
concept PitInferenceRule base PitClassifierRule {
    reference returnType?: PiClassifier;
    exp: PitExp;
}
concept PitLimitedRule base PitClassifierRule {
    statements: PitStatement[];
}
concept PitSingleRule {
    kind: PitStatementKind;
    exp: PitExp;
}
concept PitProperty base PiProperty {
}

// expressions used in type def
abstract expression PitExp {
//    appliedFeature?: PitAppliedExp;
}
abstract expression PitAppliedExp base PitExp {
    source?: PitExp;
}
expression PitExpWithType base PitExp {
    reference expectedType: PiClassifier;
    inner: PitExp;
}
expression PitSelfExp base PitExp {
}
expression PitAnytypeExp base PitExp {
}
expression PitPropertyCallExp base PitAppliedExp {
    reference property: PitProperty;
}
expression PitInstanceExp base PitExp {
    reference myLimited?: PiLimitedConcept;
    reference myInstance: PiInstance;
}
expression PitWhereExp base PitExp {
    otherType: PitProperty; // this object is not part of the AST, it is here to embody e.g. 'x: UnitOfMeasurement'
    conditions: PitStatement[];
}
abstract binary expression PitStatement base PitExp {
    left: PitExp;
    right: PitExp;
//    operand: PitStatementKind; // either 'equalsto' or 'conformsto'
}
binary expression PitEquals base PitStatement {
    priority = 8;
}
binary expression PitConforms base PitStatement {
    priority = 4;
}
expression PitFunctionCallExp base PitExp {
    calledFunction: identifier;
    // reference calledFunction: PitFunction;
    reference returnType?: PiClassifier;
    arguments: PitExp[];
}
limited PitFunction {
    name: identifier;
    numberOfArguments: number;
    // TODO do we need a returnType? It can NOT have PiClassifier as type!!
    // reference returnType: PiClassifier;
    commonSuperType = { numberOfArguments: 2 }
    typeof = { numberOfArguments: 1 }
}
// end typer definition
