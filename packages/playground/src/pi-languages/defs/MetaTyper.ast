language PiLanguage

// begin typer definition
modelunit PiTyperDef {
    name: identifier = "TYPER";
    location?: PiParseLocation;
    reference types: PiClassifier[];
    anyTypeRule?: PitAnyTypeRule;
    classifierRules: PitClassifierRule[];
    reference typeroot?: PiClassifier;
    file-extension = "type";
}

limited PitStatementKind {
    EQUALS = {name: "equalsto"}
    CONFORMS = {name: "conformsto"}
}

concept PitAnyTypeRule {
    myRules: PitXXX[];
}

abstract concept PitClassifierRule {
    reference myClassifier: PiClassifier;
}

concept PitConformanceOrEqualsRule base PitClassifierRule {
    myRules: PitXXX[];
}

concept PitXXX {
    kind: PitStatementKind;
    exp?: PitExp;
    other?: PitOtherType;
}

concept PitOtherType {
    otherType: PitProperty; // this object is not part of the AST, it is here to embody e.g. 'x: UnitOfMeasurement'
    conditions: PitStatement[];
}

concept PitInferenceRule base PitClassifierRule {
    isAbstract: boolean;
    exp?: PitExp;
    other?: PitOtherType;
}

concept PitLimitedRule base PitClassifierRule {
    statements: PitStatement[];
}

concept PitStatement {
    left: PitExp;
    right: PitExp;
    operand: PitStatementKind; // either 'equalsto' or 'conformsto'
}

abstract concept PitExp {
}
abstract concept Applied base PitExp {
}
concept PitFunctionCallExp base Applied {
    functionName: identifier;
    arguments: PitExp[];
    applied?: Applied;
}
concept PitSelfExp base PitExp {
    applied: Applied;
}
concept PitPropertyRef base PitExp {
    reference p: PitProperty;
    applied: Applied;
}

concept PitPropertyCallExp base Applied {
    reference myProperty: PiProperty;
    applied?: Applied;
}

concept PitInstanceRef base PitExp {
    reference myLimited?: PiLimitedConcept; // self.myLimited = self.limited ?? ancestor(PitLimitedRule).myClassifier;
    reference myInstance: PiInstance;
}

concept PitAnytypeRef base PitExp {
}

concept PitProperty base PiProperty {
}
// end typer definition
