// Generated by the ProjectIt Language Generator.
import { Language, PiElement, PiTyperPart, CommonSuperTypeUtil, PiType } from "@projectit/core";
import {
    GenericKind,
    GenericType,
    NamedType, PiElementReference, PredefinedType,
    TopType,
    UnitOfMeasurement
} from "../language/gen";
import { ProjectXTyper } from "./gen";
import { ProjectXEnvironment } from "../environment/gen/ProjectXEnvironment";
import { ListUtil } from "./ListUtil";


/**
 * Class 'CustomProjectXTyperPart' is meant to be a convient place to add any
 * custom code for type checking.
 */
export class CustomProjectXTyperPart implements PiTyperPart {
    mainTyper: ProjectXTyper;

    /**
     * See interface
     */
    public inferType(modelelement: PiElement): PiType | null {
        return null;
    }

    /**
     * See interface
     */
    public equalsType(elem1: PiElement, elem2: PiElement): boolean | null {
        const writer = ProjectXEnvironment.getInstance().writer;
        // console.log(`CUSTOM.equalsType() elements: ${writer.writeToString(elem1)} [${elem1.constructor.name}] ${writer.writeToString(elem2)} [${elem2.constructor.name}]`)
        const type1: PiElement = this.mainTyper.inferType(elem1);
        const type2: PiElement = this.mainTyper.inferType(elem2);
        // console.log(`CUSTOM.equalsType() types: ${type1?.name} ${type2?.name}`)

        let result: boolean = false;
        if (type1 === null || type1 === undefined) {
            // console.log("found null type for "+ writer.writeToString(elem1) + ', ' + elem1.piLanguageConcept());
            result = false;
        } else if (type2 === null || type2 === undefined) {
            // console.log("found null type for "+ writer.writeToString(elem2) + ', ' + elem2.piLanguageConcept());
            result = false;
        } else if (type1.piLanguageConcept() !== type2.piLanguageConcept()) {
            // console.log("language concepts wrong: " + type1.piLanguageConcept() + ", " + type2.piLanguageConcept())
            result = false;
        } else if (type1.piLanguageConcept() === "PredefinedType") {
            result = type1 === type2;
            // console.log(`PredefinedType: ${type1.name} ${type2.name} => ${result}`)
        } else if (type1.piLanguageConcept() === "NamedType") {
            // equalsto aa:NamedType where {
            //     aa.name equalsto self.name;
            // };
            // console.log("NamedType")
        } else if (type1.piLanguageConcept() === "GenericType") {
            // equalsto x:GenericType where {
            //     x.innerType equalsto self.innerType;
            //     x.kind equalsto self.kind;
            // };
            if ((type1 as GenericType).$kind === GenericKind.Sequence || (type1 as GenericType).$kind === GenericKind.Set) {
                // console.log("CUSTOM.equalsType: GenericType: " + writer.writeToString(type1) + writer.writeToString(type2));
            }
            const condition1: boolean = this.mainTyper.equalsType((type1 as GenericType).$baseType, (type2 as GenericType).$baseType);
            const condition2: boolean = (type1 as GenericType).kind.referred === (type2 as GenericType).kind.referred;
            // console.log("GenericType: " + writer.writeToString(elem1) + condition1 + ", " + condition2);
            result = condition1 && condition2;
        } else if (type1.piLanguageConcept() === "UnitOfMeasurement") {
            // equalsto aap:UnitOfMeasurement where {
            //     aap.baseType equalsto self.baseType;
            //     aap.unit equalsto self.unit;
            // };
            const condition1: boolean = this.mainTyper.equalsType((type1 as UnitOfMeasurement).baseType.referred, (type2 as UnitOfMeasurement).baseType.referred);
            const condition2: boolean = (type1 as UnitOfMeasurement).unit.referred === (type2 as UnitOfMeasurement).unit.referred;
            // console.log("UnitOfMeasurement " + writer.writeToString(elem1) + condition1 + ", " + condition2);
            result = condition1 && condition2;
        }
        // console.log("CUSTOM.equalsType: " + writer.writeNameOnly(elem1) + ", " + writer.writeNameOnly(elem2)
        //     + "\n\t types are: " + writer.writeNameOnly(type1) + ", " + writer.writeNameOnly(type2)
        //     + "\n\t ids of types are: " + type1?.piId() + ", " + type2?.piId()
        //     + "\n\t result: " + result);
        return result;
    }

    /**
     * See interface
     */
    public conformsTo(elem1: PiElement, elem2: PiElement): boolean | null {
        return null;
    }

    /**
     * See interface
     */
    public conformList(typelist1: PiElement[], typelist2: PiElement[]): boolean | null {
        return null;
    }

    /**
     * See interface
     */
    public isType(elem: PiElement): boolean | null {
        return null;
    }

    public commonSuperType(inlist: PiElement[]): TopType | null {
        const writer = ProjectXEnvironment.getInstance().writer;

        // check if we have real types in the typelist
        const typelist: TopType[] = [];
        for (const elem of inlist) {
            ListUtil.addIfNotPresent(typelist, this.mainTyper.inferType(elem));
        }
        const result = CommonSuperTypeUtil.commonSuperType(typelist);
        // console.log("CUSTOM.commonSuperType: " + typelist.map(type => writer.writeNameOnly(type)).join(", ") + "\n\tresult: " + result.map(type => writer.writeNameOnly(type)).join(", ") + " " +result[0]?.piLanguageConcept());

        if (!!result && result.length > 0) {
            const concept = result[0].piLanguageConcept();
            if (concept === "TopType" || Language.getInstance().subConcepts("TopType").includes(concept)) {
                return result[0] as TopType;
            }
        }
        return null;
    }

    getSupers(elem: PiElement): PiElement[] {
        const writer = ProjectXEnvironment.getInstance().writer;
        // console.log(`CUSTOM.getSupers() element: ${writer.writeToString(elem)} [${elem.constructor.name}]`);
        if (elem === PredefinedType.NUMBER || elem === PredefinedType.BOOLEAN) {
            return [PredefinedType.STRING];
        } else if (elem === GenericKind.Bag || elem === GenericKind.Set || elem === GenericKind.Sequence) {
            return [GenericKind.Collection];
        } else if (elem.piLanguageConcept() === "GenericType") {
            const superKinds: PiElement[] = this.getSupers((elem as GenericType).$kind);
            const superBaseTypes: PiElement[] = this.getSupers((elem as GenericType).$baseType);
            const result: GenericType[] = [];
            for (const superKind of superKinds) {
                if (superKind.piLanguageConcept() === "GenericKind" && superKind != (elem as GenericType).$kind) {
                    result.push(GenericType.create({
                        baseType: PiElementReference.create<TopType>((elem as GenericType).$baseType, "TopType"),
                        kind: PiElementReference.create<GenericKind>(superKind as GenericKind, "GenericKind")
                    }));
                    let first: boolean = true;
                    for (const superBaseType of superBaseTypes) {
                        const concept = superBaseType.piLanguageConcept();
                        if (concept === "TopType" || Language.getInstance().subConcepts("TopType").includes(concept)) {
                            if (first) { // add this element before the others, otherwise the wrong result will be given by commonSuperType
                                result.push(GenericType.create({
                                    baseType: PiElementReference.create<TopType>(superBaseType as TopType, "TopType"),
                                    kind: PiElementReference.create<GenericKind>((elem as GenericType).$kind, "GenericKind")
                                }));
                                first = false;
                            }
                            result.push(GenericType.create({
                                baseType: PiElementReference.create<TopType>(superBaseType as TopType, "TopType"),
                                kind: PiElementReference.create<GenericKind>(superKind as GenericKind, "GenericKind")
                            }));
                        }
                    }
                }
            }
            console.log(`CUSTOM.getSupers() element: ${writer.writeToString(elem)} [${elem.constructor.name}] result: [${result.map(e => writer.writeToString(e)).join(", ")}]`);
            return result;
        }
        return [];
    }

    private printType(element: TopType): string {
        if (element.piLanguageConcept() === "GenericType") {
            return (element as GenericType).kind.name + "<" + this.printType((element as GenericType).$baseType) + ">";
        } else if (element.piLanguageConcept() === "UnitOfMeasurement") {
            return (element as UnitOfMeasurement).unit.name + "<" + this.printType((element as UnitOfMeasurement).$baseType) + ">";
        } else{
            return element.name;
        }
    }
}
