// Generated by the ProjectIt Language Generator.
import { Language, Model, ModelUnit, Property, Concept, Interface, PiNamedElement } from "@projectit/core";

import {
    XX,
    XXunit,
    ExpWithType,
    NamedType,
    PredefinedType,
    GenericType,
    GenericKind,
    UnitOfMeasurement,
    UnitKind,
    Exp,
    NumberLiteral,
    StringLiteral,
    BooleanLiteral,
    NamedExp,
    PlusExp,
    UnitLiteral,
    GenericLiteral,
    PiElementReference, TopType
} from "./internal";

/**
 * Creates an in-memory representation of structure of the language metamodel, used in e.g. the (de)serializer.
 */
export function initializeLanguage() {
    Language.getInstance().addModel(describeXX());
    Language.getInstance().addUnit(describeXXunit());
    Language.getInstance().addConcept(describeExpWithType());
    Language.getInstance().addConcept(describeNamedType());
    Language.getInstance().addConcept(describePredefinedType());
    Language.getInstance().addConcept(describeGenericType());
    Language.getInstance().addConcept(describeGenericKind());
    Language.getInstance().addConcept(describeUnitOfMeasurement());
    Language.getInstance().addConcept(describeUnitKind());
    Language.getInstance().addConcept(describeExp());
    Language.getInstance().addConcept(describeNumberLiteral());
    Language.getInstance().addConcept(describeStringLiteral());
    Language.getInstance().addConcept(describeBooleanLiteral());
    Language.getInstance().addConcept(describeNamedExp());
    Language.getInstance().addConcept(describePlusExp());
    Language.getInstance().addConcept(describeUnitLiteral());
    Language.getInstance().addConcept(describeGenericLiteral());
    Language.getInstance().addInterface(describeTopType());
    Language.getInstance().addReferenceCreator((name: string, type: string) => {
        if (!!name) {
            const allNames: string[] = splitRefName(name);
            const result = makeReference(allNames, 0, type);
            console.log("Reference: " + result.name);
            return result;
        } else {
            return null;
        }
    });
}

function makeReference(allNames: string[], startFrom: number, type: string): PiElementReference<any> | null {
    // console.log(allNames.map(n => n).join("---")+ ", starting from:" + startFrom)
    if (startFrom === allNames.length - 1) { // the last should be a 'normal' reference
        // console.log("returning 'Normal': " + allNames[startFrom] + ", type: " + type)
        return PiElementReference.create(allNames[startFrom], type);
    } else {
        const firstName: string = allNames[startFrom];
        let element: PiNamedElement = null;
        if (firstName === "GenericType") {
            let genericKind: GenericKind = GenericKind.find(allNames[startFrom + 1]);
            const refToKind: PiElementReference<GenericKind> = PiElementReference.create<GenericKind>(genericKind, "GenericKind");
            const refToBaseType: PiElementReference<TopType> = makeReference(allNames, startFrom + 2, type);
            element = GenericType.create({ kind: refToKind, baseType: refToBaseType });
            console.log("DOING GENERIC: " + printType(element) + ", type: " + type)
        } else if (firstName === "UnitOfMeasurement") {
            let unitKind: UnitKind = UnitKind.find(allNames[startFrom + 1]);
            const refToUnit: PiElementReference<UnitKind> = PiElementReference.create<UnitKind>(unitKind, "UnitKind");
            const refToBaseType: PiElementReference<PredefinedType> = makeReference(allNames, startFrom + 2, type);
            element = UnitOfMeasurement.create({ unit: refToUnit, baseType: refToBaseType });
            console.log("DOING MEASUREMENT: " + printType(element) + ", type: " + type)
        }
        return PiElementReference.create(element, type);
    }
}
function printType(element: TopType): string {
    if (element.piLanguageConcept() === "GenericType") {
        return (element as GenericType).kind.name + "<" + printType((element as GenericType).$baseType) + ">";
    } else if (element.piLanguageConcept() === "UnitOfMeasurement") {
        return (element as UnitOfMeasurement).unit.name + "<" + printType((element as UnitOfMeasurement).$baseType) + ">";
    } else{
        return element.name;
    }
}

function splitRefName(inName: string): string[] {
    const names: string[] = [];
    let allNames: string[] = inName.split("_");
    for (const name of allNames) {
        if (name !== "$pi" && name !== "generated") {
            names.push(name);
        }
    }
    return names;
}

function describeXX(): Model {
    const model = {
        typeName: "XX",
        constructor: () => {
            return new XX();
        },
        properties: new Map<string, Property>()
    };
    model.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyType: "primitive"
    });
    model.properties.set("units", {
        name: "units",
        type: "XXunit",
        isList: true,
        isPublic: false,
        propertyType: "part"
    });

    return model;
}

function describeXXunit(): ModelUnit {
    const modelunit = {
        typeName: "XXunit",
        fileExtension: "xxx",
        constructor: () => {
            return new XXunit();
        },
        properties: new Map<string, Property>()
    };
    modelunit.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyType: "primitive"
    });
    modelunit.properties.set("namedConcepts", {
        name: "namedConcepts",
        type: "NamedType",
        isList: true,
        isPublic: false,
        propertyType: "part"
    });
    modelunit.properties.set("lines", {
        name: "lines",
        type: "ExpWithType",
        isList: true,
        isPublic: false,
        propertyType: "part"
    });

    return modelunit;
}

function describeExpWithType(): Concept {
    const concept = {
        typeName: "ExpWithType",
        isAbstract: false,
        isPublic: undefined,
        trigger: "ExpWithType",
        constructor: () => {
            return new ExpWithType();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };

    concept.properties.set("expr", {
        name: "expr",
        type: "Exp",
        isList: false,
        isPublic: false,
        propertyType: "part"
    });
    concept.properties.set("type", {
        name: "type",
        type: "TopType",
        isList: false,
        isPublic: false,
        propertyType: "reference"
    });
    return concept;
}

function describeNamedType(): Concept {
    const concept = {
        typeName: "NamedType",
        isAbstract: false,
        isPublic: undefined,
        trigger: "NamedType",
        constructor: () => {
            return new NamedType();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: ["PredefinedType"]
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    return concept;
}

function describePredefinedType(): Concept {
    const concept = {
        typeName: "PredefinedType",
        isAbstract: false,
        isPublic: undefined,
        trigger: "PredefinedType",
        constructor: () => {
            return new PredefinedType();
        },
        properties: new Map<string, Property>(),
        baseName: "NamedType",
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    return concept;
}

function describeGenericType(): Concept {
    const concept = {
        typeName: "GenericType",
        isAbstract: false,
        isPublic: undefined,
        trigger: "GenericType",
        constructor: () => {
            return new GenericType();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    concept.properties.set("baseType", {
        name: "baseType",
        type: "TopType",
        isList: false,
        isPublic: false,
        propertyType: "reference"
    });
    concept.properties.set("kind", {
        name: "kind",
        type: "GenericKind",
        isList: false,
        isPublic: false,
        propertyType: "reference"
    });
    return concept;
}

function describeGenericKind(): Concept {
    const concept = {
        typeName: "GenericKind",
        isAbstract: false,
        isPublic: undefined,
        trigger: "GenericKind",
        constructor: () => {
            return new GenericKind();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    return concept;
}

function describeUnitOfMeasurement(): Concept {
    const concept = {
        typeName: "UnitOfMeasurement",
        isAbstract: false,
        isPublic: undefined,
        trigger: "UnitOfMeasurement",
        constructor: () => {
            return new UnitOfMeasurement();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    concept.properties.set("baseType", {
        name: "baseType",
        type: "PredefinedType",
        isList: false,
        isPublic: false,
        propertyType: "reference"
    });
    concept.properties.set("unit", {
        name: "unit",
        type: "UnitKind",
        isList: false,
        isPublic: false,
        propertyType: "reference"
    });
    return concept;
}

function describeUnitKind(): Concept {
    const concept = {
        typeName: "UnitKind",
        isAbstract: false,
        isPublic: undefined,
        trigger: "UnitKind",
        constructor: () => {
            return new UnitKind();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    return concept;
}

function describeExp(): Concept {
    const concept = {
        typeName: "Exp",
        isAbstract: true,
        isPublic: undefined,
        trigger: "Exp",
        constructor: () => {
            return null;
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: ["NumberLiteral", "StringLiteral", "BooleanLiteral", "NamedExp", "PlusExp", "UnitLiteral", "GenericLiteral"]
    };

    return concept;
}

function describeNumberLiteral(): Concept {
    const concept = {
        typeName: "NumberLiteral",
        isAbstract: false,
        isPublic: undefined,
        trigger: "NumberLiteral",
        constructor: () => {
            return new NumberLiteral();
        },
        properties: new Map<string, Property>(),
        baseName: "Exp",
        subConceptNames: []
    };
    concept.properties.set("xx", {
        name: "xx",
        type: "number",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    return concept;
}

function describeStringLiteral(): Concept {
    const concept = {
        typeName: "StringLiteral",
        isAbstract: false,
        isPublic: undefined,
        trigger: "StringLiteral",
        constructor: () => {
            return new StringLiteral();
        },
        properties: new Map<string, Property>(),
        baseName: "Exp",
        subConceptNames: []
    };
    concept.properties.set("xx", {
        name: "xx",
        type: "string",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    return concept;
}

function describeBooleanLiteral(): Concept {
    const concept = {
        typeName: "BooleanLiteral",
        isAbstract: false,
        isPublic: undefined,
        trigger: "BooleanLiteral",
        constructor: () => {
            return new BooleanLiteral();
        },
        properties: new Map<string, Property>(),
        baseName: "Exp",
        subConceptNames: []
    };
    concept.properties.set("xx", {
        name: "xx",
        type: "boolean",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    return concept;
}

function describeNamedExp(): Concept {
    const concept = {
        typeName: "NamedExp",
        isAbstract: false,
        isPublic: undefined,
        trigger: "NamedExp",
        constructor: () => {
            return new NamedExp();
        },
        properties: new Map<string, Property>(),
        baseName: "Exp",
        subConceptNames: []
    };

    concept.properties.set("inner", {
        name: "inner",
        type: "Exp",
        isList: false,
        isPublic: false,
        propertyType: "part"
    });
    concept.properties.set("myType", {
        name: "myType",
        type: "NamedType",
        isList: false,
        isPublic: false,
        propertyType: "part"
    });

    return concept;
}

function describePlusExp(): Concept {
    const concept = {
        typeName: "PlusExp",
        isAbstract: false,
        isPublic: undefined,
        trigger: "PlusExp",
        constructor: () => {
            return new PlusExp();
        },
        properties: new Map<string, Property>(),
        baseName: "Exp",
        subConceptNames: []
    };

    concept.properties.set("left", {
        name: "left",
        type: "Exp",
        isList: false,
        isPublic: false,
        propertyType: "part"
    });
    concept.properties.set("right", {
        name: "right",
        type: "Exp",
        isList: false,
        isPublic: false,
        propertyType: "part"
    });

    return concept;
}

function describeUnitLiteral(): Concept {
    const concept = {
        typeName: "UnitLiteral",
        isAbstract: false,
        isPublic: undefined,
        trigger: "UnitLiteral",
        constructor: () => {
            return new UnitLiteral();
        },
        properties: new Map<string, Property>(),
        baseName: "Exp",
        subConceptNames: []
    };

    concept.properties.set("inner", {
        name: "inner",
        type: "NumberLiteral",
        isList: false,
        isPublic: false,
        propertyType: "part"
    });
    concept.properties.set("unit", {
        name: "unit",
        type: "UnitKind",
        isList: false,
        isPublic: false,
        propertyType: "reference"
    });
    return concept;
}

function describeGenericLiteral(): Concept {
    const concept = {
        typeName: "GenericLiteral",
        isAbstract: false,
        isPublic: undefined,
        trigger: "GenericLiteral",
        constructor: () => {
            return new GenericLiteral();
        },
        properties: new Map<string, Property>(),
        baseName: "Exp",
        subConceptNames: []
    };

    concept.properties.set("content", {
        name: "content",
        type: "Exp",
        isList: true,
        isPublic: false,
        propertyType: "part"
    });
    concept.properties.set("kind", {
        name: "kind",
        type: "GenericKind",
        isList: false,
        isPublic: false,
        propertyType: "reference"
    });
    return concept;
}

function describeTopType(): Interface {
    const intface = {
        typeName: "TopType",
        isPublic: undefined,
        properties: new Map<string, Property>(),
        subConceptNames: ["NamedType", "PredefinedType", "GenericType", "UnitOfMeasurement"]
    };
    intface.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: false,
        propertyType: "primitive"
    });

    return intface;
}
