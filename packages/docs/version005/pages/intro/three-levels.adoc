:imagesdir: ../images/
:page-nav_order: 50
:page-title: Three Levels to Define your Pi-tools
:page-parent: ProjectIt - Introduction
:src-dir: ../../../src/tutorial-language/defs
:projectitdir: ../../../core
:source-language: javascript
:listing-caption: Code Sample
:icons: font
[[levels]]
= Three Levels to Define your Pi-tools

From the five parts of the language definition ProjectIt generates a workbench containing an editor, scoper, typer,
and validator, and some utilities like a parser/deparser. All of these are called *pi-tools*.

You, the language engineer, can fine-tune the generated pi-tools. We call this manner of fine-tuning: working in three levels.
This three-level approach makes it possible to create your language step-by-step, in an agile fashion.
(Read our xref:../meta-documentation/philosophy.adoc[philosophy] to understand why we have choosen these levels.)

. On the first level, based solely on the AST, defaults are generated for every part of the workbench. For instance, the default scoper
simply finds that every name in a model is visible everywhere.
. On the second level, the other definitions (in the `.edit`, `.scope`, `.valid`, and `.type` files) are
taken into account. When a definition for the editor, for instance, is present, it is used to generate a more
suitable solution. The presentation in the editor could be more concise, using certain keywords etc. More on how to
utilize the second level can be found in our xref:../second-level/tutorials-intro.adoc[tutorials].
. The third level takes some hand-coding, but produces a result that is extremely adjusted to your needs. More
on how to use the third level can be found in the tutorial on xref:../third-level/framework-tutorial.adoc[Using the Framework].

ProjectIt will combine definitions in each level into one application, where the third level proceeds the second, and
the second level proceeds the first. For instance,
the generated editor will per xref:../second-level/langdef-tutorial.adoc#concept[*concept*] in the language:

. use the _hand-made projection_, when this is present. If not, the editor will
. use the _projection generated from the editor definition_, when this definition is present. Finally, when no
other definition is present, the editor will
. use the _default projection_, the one generated when no `.edit` definition file is present.

For now this approach is implemented for the editor and validator, in future this will also apply to the
scoper and typer.

